module.exports = {"dash":"# baseURI: http://datashapes.org/dash\n# imports: http://www.w3.org/ns/shacl#\n# prefix: dash\n\n@prefix dash: <http://datashapes.org/dash#> .\n@prefix owl: <http://www.w3.org/2002/07/owl#> .\n@prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .\n@prefix rdfs: <http://www.w3.org/2000/01/rdf-schema#> .\n@prefix sh: <http://www.w3.org/ns/shacl#> .\n@prefix xsd: <http://www.w3.org/2001/XMLSchema#> .\n\n<http://datashapes.org/dash>\n  rdf:type owl:Ontology ;\n  rdfs:comment \"\"\"DASH defines SPARQL-based validators for many SHACL Core constraint components. These are (among others) utilized by TopBraid and its API. Note that constraint components that require validation of nested shapes (such as sh:node) are not implementable without a function such as tosh:hasShape.\n\nDASH is also a SHACL library for frequently needed features and design patterns. All features in this library are 100% standards compliant and will work on any engine that fully supports SHACL.\"\"\" ;\n  rdfs:label \"DASH Data Shapes Library\" ;\n  owl:imports sh: ;\n  sh:declare [\n      sh:namespace \"http://datashapes.org/dash#\"^^xsd:anyURI ;\n      sh:prefix \"dash\" ;\n    ] ;\n  sh:declare [\n      sh:namespace \"http://purl.org/dc/terms/\"^^xsd:anyURI ;\n      sh:prefix \"dcterms\" ;\n    ] ;\n  sh:declare [\n      sh:namespace \"http://www.w3.org/1999/02/22-rdf-syntax-ns#\"^^xsd:anyURI ;\n      sh:prefix \"rdf\" ;\n    ] ;\n  sh:declare [\n      sh:namespace \"http://www.w3.org/2000/01/rdf-schema#\"^^xsd:anyURI ;\n      sh:prefix \"rdfs\" ;\n    ] ;\n  sh:declare [\n      sh:namespace \"http://www.w3.org/2001/XMLSchema#\"^^xsd:anyURI ;\n      sh:prefix \"xsd\" ;\n    ] ;\n  sh:declare [\n      sh:namespace \"http://www.w3.org/2002/07/owl#\"^^xsd:anyURI ;\n      sh:prefix \"owl\" ;\n    ] ;\n  sh:declare [\n      sh:namespace \"http://www.w3.org/2004/02/skos/core#\"^^xsd:anyURI ;\n      sh:prefix \"skos\" ;\n    ] ;\n.\ndash:AllObjects\n  rdf:type dash:AllObjectsTarget ;\n  rdfs:comment \"A reusable instance of dash:AllObjectsTarget.\" ;\n  rdfs:label \"All objects\" ;\n.\ndash:AllObjectsTarget\n  rdf:type sh:JSTargetType ;\n  rdf:type sh:SPARQLTargetType ;\n  rdfs:comment \"A target containing all objects in the data graph as focus nodes.\" ;\n  rdfs:label \"All objects target\" ;\n  rdfs:subClassOf sh:Target ;\n  sh:jsFunctionName \"dash_allObjects\" ;\n  sh:jsLibrary dash:DASHJSLibrary ;\n  sh:labelTemplate \"All objects\" ;\n  sh:prefixes <http://datashapes.org/dash> ;\n  sh:select \"\"\"SELECT DISTINCT ?this\nWHERE {\n    ?anyS ?anyP ?this .\n}\"\"\" ;\n.\ndash:AllSubjects\n  rdf:type dash:AllSubjectsTarget ;\n  rdfs:comment \"A reusable instance of dash:AllSubjectsTarget.\" ;\n  rdfs:label \"All subjects\" ;\n.\ndash:AllSubjectsTarget\n  rdf:type sh:JSTargetType ;\n  rdf:type sh:SPARQLTargetType ;\n  rdfs:comment \"A target containing all subjects in the data graph as focus nodes.\" ;\n  rdfs:label \"All subjects target\" ;\n  rdfs:subClassOf sh:Target ;\n  sh:jsFunctionName \"dash_allSubjects\" ;\n  sh:jsLibrary dash:DASHJSLibrary ;\n  sh:labelTemplate \"All subjects\" ;\n  sh:prefixes <http://datashapes.org/dash> ;\n  sh:select \"\"\"SELECT DISTINCT ?this\nWHERE {\n    ?this ?anyP ?anyO .\n}\"\"\" ;\n.\ndash:ClosedByTypesConstraintComponent\n  rdf:type sh:ConstraintComponent ;\n  rdfs:comment \"A constraint component that can be used to declare that focus nodes are \\\"closed\\\" based on their rdf:types, meaning that focus nodes may only have values for the properties that are explicitly enumerated via sh:property/sh:path in property constraints at their rdf:types and the superclasses of those. This assumes that the type classes are also shapes.\" ;\n  rdfs:label \"Closed by types constraint component\" ;\n  sh:nodeValidator [\n      rdf:type sh:JSValidator ;\n      sh:jsFunctionName \"validateClosedByTypesNode\" ;\n      sh:jsLibrary dash:DASHJSLibrary ;\n      sh:message \"Property is not among those permitted for any of the types\" ;\n    ] ;\n  sh:nodeValidator [\n      rdf:type sh:SPARQLSelectValidator ;\n      sh:message \"Property {?path} is not among those permitted for any of the types\" ;\n      sh:prefixes <http://datashapes.org/dash> ;\n      sh:select \"\"\"SELECT $this (?predicate AS ?path) ?value\nWHERE {\n\tFILTER ($closedByTypes) .\n    $this ?predicate ?value .\n\tFILTER (?predicate != rdf:type) .\n\tFILTER NOT EXISTS {\n\t\t$this rdf:type ?type .\n\t\t?type rdfs:subClassOf* ?class .\n\t\tGRAPH $shapesGraph {\n\t\t\t?class sh:property/sh:path ?predicate .\n\t\t}\n\t}\n}\"\"\" ;\n    ] ;\n  sh:parameter dash:ClosedByTypesConstraintComponent-closedByTypes ;\n  sh:targetClass sh:NodeShape ;\n.\ndash:ClosedByTypesConstraintComponent-closedByTypes\n  rdf:type sh:Parameter ;\n  sh:path dash:closedByTypes ;\n  sh:datatype xsd:boolean ;\n  sh:description \"True to indicate that the focus nodes are closed by their types. A constraint violation is reported for each property value of the focus node where the property is not among those that are explicitly declared via sh:property/sh:path in any of the rdf:types of the focus node (and their superclasses). The property rdf:type is always permitted.\" ;\n.\ndash:CoExistsWithConstraintComponent\n  rdf:type sh:ConstraintComponent ;\n  dash:localConstraint \"true\"^^xsd:boolean ;\n  rdfs:comment \"A constraint component that can be used to express a constraint on property shapes so that if the property path has any value then the given property must also have a value, and vice versa.\" ;\n  rdfs:label \"Co-exists-with constraint component\" ;\n  sh:message \"Values must co-exist with values of {$coExistsWith}\" ;\n  sh:parameter dash:CoExistsWithConstraintComponent-coExistsWith ;\n  sh:propertyValidator [\n      rdf:type sh:JSValidator ;\n      sh:jsFunctionName \"validateCoExistsWith\" ;\n      sh:jsLibrary dash:DASHJSLibrary ;\n    ] ;\n  sh:propertyValidator [\n      rdf:type sh:SPARQLSelectValidator ;\n      sh:prefixes <http://datashapes.org/dash> ;\n      sh:select \"\"\"SELECT $this\nWHERE {\n\t{\n    \tFILTER (EXISTS { $this $PATH ?any } && NOT EXISTS { $this $coExistsWith ?any })\n\t}\n\tUNION\n\t{\n    \tFILTER (NOT EXISTS { $this $PATH ?any } && EXISTS { $this $coExistsWith ?any })\n\t}\n}\"\"\" ;\n    ] ;\n  sh:targetClass sh:PropertyShape ;\n.\ndash:CoExistsWithConstraintComponent-coExistsWith\n  rdf:type sh:Parameter ;\n  sh:path dash:coExistsWith ;\n  sh:class rdf:Property ;\n  sh:nodeKind sh:IRI ;\n.\ndash:DASHJSLibrary\n  rdf:type sh:JSLibrary ;\n  rdfs:label \"DASH JavaScript library\" ;\n  sh:jsLibrary dash:RDFQueryJSLibrary ;\n  sh:jsLibraryURL \"http://datashapes.org/js/dash.js\"^^xsd:anyURI ;\n.\ndash:DateOrDateTime\n  rdf:type rdf:List ;\n  rdf:first xsd:date ;\n  rdf:rest (\n      xsd:dateTime\n    ) ;\n  rdfs:comment \"An rdf:List that can be used in property constraints as value for sh:or to indicate that all values of a property must be either xsd:date or xsd:dateTime.\" ;\n  rdfs:label \"Date or date time\" ;\n.\ndash:DefaultValueTypeRule\n  rdf:type sh:SPARQLConstructExecutable ;\n  rdfs:comment \"\"\"\n\t\tA resource encapsulating a query that can be used to construct rdf:type triples for certain untyped nodes\n\t\tthat are an object in a triple where the predicate has a sh:defaultValueType.\n\t\tThis can be used as a pre-processor for shape graphs before they are validated.\n\t\t\"\"\"^^rdf:HTML ;\n  rdfs:label \"default value type inference rule\" ;\n  sh:construct \"\"\"\n\t\tCONSTRUCT {\n\t\t\t?node a ?defaultValueType .\n\t\t}\n\t\tWHERE {\n\t\t\t?predicate sh:defaultValueType ?defaultValueType .\n\t\t\t?anySubject ?predicate ?node .\n\t\t\tFILTER (NOT EXISTS { ?node a ?anyType }) .\n\t\t}\n\t\t\"\"\" ;\n.\ndash:FailureResult\n  rdf:type rdfs:Class ;\n  rdfs:comment \"A result representing a validation failure such as an unsupported recursion.\" ;\n  rdfs:label \"Failure result\" ;\n  rdfs:subClassOf sh:AbstractResult ;\n.\ndash:FailureTestCaseResult\n  rdf:type rdfs:Class ;\n  rdfs:comment \"Represents a failure of a test case.\" ;\n  rdfs:label \"Failure test case result\" ;\n  rdfs:subClassOf dash:TestCaseResult ;\n.\ndash:FunctionTestCase\n  rdf:type rdfs:Class ;\n  rdfs:comment \"A test case that verifies that a given SPARQL expression produces a given, expected result.\" ;\n  rdfs:label \"Function test case\" ;\n  rdfs:subClassOf dash:TestCase ;\n  sh:property [\n      sh:path dash:expectedResult ;\n      sh:description \"The expected result of a function call.\" ;\n      sh:maxCount 1 ;\n      sh:name \"expected result\" ;\n    ] ;\n  sh:property [\n      sh:path dash:expression ;\n      sh:description \"A valid SPARQL expression calling the function to test.\" ;\n      sh:maxCount 1 ;\n      sh:minCount 1 ;\n      sh:name \"expression\" ;\n    ] ;\n.\ndash:GraphUpdate\n  rdf:type rdfs:Class ;\n  rdfs:label \"Graph update\" ;\n  rdfs:subClassOf dash:Suggestion ;\n.\ndash:GraphValidationTestCase\n  rdf:type rdfs:Class ;\n  rdfs:comment \"A test case that performs SHACL constraint validation on the whole graph and compares the results with the expected validation results stored with the test case. By default this excludes meta-validation (i.e. the validation of the shape definitions themselves). If that's desired, set dash:validateShapes to true.\" ;\n  rdfs:label \"Graph validation test case\" ;\n  rdfs:subClassOf dash:ValidationTestCase ;\n.\ndash:HasValueWithClassConstraintComponent\n  rdf:type sh:ConstraintComponent ;\n  rdfs:comment \"A constraint component that can be used to express a constraint on property shapes so that one of the values of the property path must be an instance of a given class.\" ;\n  rdfs:label \"Has value with class constraint component\" ;\n  sh:message \"At least one of the values must have class {$hasValueWithClass}\" ;\n  sh:parameter dash:HasValueWithClassConstraintComponent-hasValueWithClass ;\n  sh:propertyValidator [\n      rdf:type sh:JSValidator ;\n      sh:jsFunctionName \"validateHasValueWithClass\" ;\n      sh:jsLibrary dash:DASHJSLibrary ;\n    ] ;\n  sh:propertyValidator [\n      rdf:type sh:SPARQLSelectValidator ;\n      sh:prefixes <http://datashapes.org/dash> ;\n      sh:select \"\"\"SELECT $this\nWHERE {\n\tFILTER NOT EXISTS {\n    \t$this $PATH ?value .\n\t\t?value a ?type .\n\t\t?type rdfs:subClassOf* ?hasValueWithClass .\n\t}\n}\"\"\" ;\n    ] ;\n  sh:targetClass sh:PropertyShape ;\n.\ndash:HasValueWithClassConstraintComponent-hasValueWithClass\n  rdf:type sh:Parameter ;\n  sh:path dash:hasValueWithClass ;\n  sh:class rdfs:Class ;\n  sh:nodeKind sh:IRI ;\n.\ndash:InferencingTestCase\n  rdf:type rdfs:Class ;\n  rdf:type sh:NodeShape ;\n  rdfs:comment \"A test case to verify whether an inferencing engine is producing identical results to those stored as expected results.\" ;\n  rdfs:label \"Inferencing test case\" ;\n  rdfs:subClassOf dash:TestCase ;\n  sh:property [\n      sh:path dash:expectedResult ;\n      sh:description \"The expected inferred triples, represented by instances of rdfs:Statement.\" ;\n      sh:name \"expected result\" ;\n    ] ;\n.\ndash:JSTestCase\n  rdf:type rdfs:Class ;\n  rdfs:comment \"A test case that calls a given JavaScript function like a sh:JSFunction and compares its result with the dash:expectedResult.\" ;\n  rdfs:label \"JavaScript test case\" ;\n  rdfs:subClassOf dash:TestCase ;\n  rdfs:subClassOf sh:JSFunction ;\n  sh:property [\n      sh:path dash:expectedResult ;\n      sh:description \"The expected result of the JavaScript function call, as an RDF node.\" ;\n      sh:maxCount 1 ;\n      sh:name \"expected result\" ;\n    ] ;\n.\ndash:ListNodeShape\n  rdf:type sh:NodeShape ;\n  rdfs:comment \"Defines constraints on what it means for a node to be a node within a well-formed RDF list. Note that this does not check whether the rdf:rest items are also well-formed lists as this would lead to unsupported recursion.\" ;\n  rdfs:label \"List node shape\" ;\n  sh:or (\n      [\n        sh:hasValue () ;\n        sh:property [\n            sh:path rdf:first ;\n            sh:maxCount 0 ;\n          ] ;\n        sh:property [\n            sh:path rdf:rest ;\n            sh:maxCount 0 ;\n          ] ;\n      ]\n      [\n        sh:not [\n            sh:hasValue () ;\n          ] ;\n        sh:property [\n            sh:path rdf:first ;\n            sh:maxCount 1 ;\n            sh:minCount 1 ;\n          ] ;\n        sh:property [\n            sh:path rdf:rest ;\n            sh:maxCount 1 ;\n            sh:minCount 1 ;\n          ] ;\n      ]\n    ) ;\n.\ndash:ListShape\n  rdf:type sh:NodeShape ;\n  rdfs:comment \"\"\"Defines constraints on what it means for a node to be a well-formed RDF list.\n\nThe focus node must either be rdf:nil or not recursive. Furthermore, this shape uses dash:ListNodeShape as a \\\"helper\\\" to walk through all members of the whole list (including itself).\"\"\" ;\n  rdfs:label \"List shape\" ;\n  sh:or (\n      [\n        sh:hasValue () ;\n      ]\n      [\n        sh:not [\n            sh:hasValue () ;\n          ] ;\n        sh:property [\n            sh:path [\n                sh:oneOrMorePath rdf:rest ;\n              ] ;\n            dash:nonRecursive \"true\"^^xsd:boolean ;\n          ] ;\n      ]\n    ) ;\n  sh:property [\n      sh:path [\n          sh:zeroOrMorePath rdf:rest ;\n        ] ;\n      rdfs:comment \"Each list member (including this node) must be have the shape dash:ListNodeShape.\" ;\n      sh:node dash:ListNodeShape ;\n    ] ;\n.\ndash:NonRecursiveConstraintComponent\n  rdf:type sh:ConstraintComponent ;\n  rdfs:comment \"\"\"Used to state that a property or path must not point back to itself.\n\nFor example, \\\"a person cannot have itself as parent\\\" can be expressed by setting dash:nonRecursive=true for a given sh:path.\n\nTo express that a person cannot have itself among any of its (recursive) parents, use a sh:path with the + operator such as ex:parent+.\"\"\" ;\n  rdfs:label \"Non-recursive constraint component\" ;\n  sh:message \"Points back at itself (recursively)\" ;\n  sh:parameter dash:NonRecursiveConstraintComponent-nonRecursive ;\n  sh:propertyValidator [\n      rdf:type sh:JSValidator ;\n      sh:jsFunctionName \"validateNonRecursiveProperty\" ;\n      sh:jsLibrary dash:DASHJSLibrary ;\n    ] ;\n  sh:propertyValidator [\n      rdf:type sh:SPARQLSelectValidator ;\n      sh:prefixes <http://datashapes.org/dash> ;\n      sh:select \"\"\"SELECT DISTINCT $this ($this AS ?value)\nWHERE {\n\t{\n\t\tFILTER (?nonRecursive)\n\t}\n    $this $PATH $this .\n}\"\"\" ;\n    ] ;\n  sh:targetClass sh:PropertyShape ;\n.\ndash:NonRecursiveConstraintComponent-nonRecursive\n  rdf:type sh:Parameter ;\n  sh:path dash:nonRecursive ;\n  sh:datatype xsd:boolean ;\n  sh:maxCount 1 ;\n  sh:name \"non-recursive\" ;\n.\ndash:None\n  rdf:type sh:NodeShape ;\n  rdfs:comment \"A Shape that is no node can conform to.\" ;\n  rdfs:label \"None\" ;\n  sh:in () ;\n.\ndash:ParameterConstraintComponent\n  rdf:type sh:ConstraintComponent ;\n  rdfs:comment \"A constraint component that can be used to verify that all value nodes conform to the given Parameter.\"@en ;\n  rdfs:label \"Parameter constraint component\"@en ;\n  sh:parameter dash:ParameterConstraintComponent-parameter ;\n.\ndash:ParameterConstraintComponent-parameter\n  rdf:type sh:Parameter ;\n  sh:path sh:parameter ;\n.\ndash:PrimaryKeyConstraintComponent\n  rdf:type sh:ConstraintComponent ;\n  dash:localConstraint \"true\"^^xsd:boolean ;\n  rdfs:comment \"Enforces a constraint that the given property (sh:path) serves as primary key for all resources in the target of the shape. If a property has been declared to be the primary key then each resource must have exactly one value for that property. Furthermore, the URIs of those resources must start with a given string (dash:uriStart), followed by the URL-encoded primary key value. For example if dash:uriStart is \\\"http://example.org/country-\\\" and the primary key for an instance is \\\"de\\\" then the URI must be \\\"http://example.org/country-de\\\". Finally, as a result of the URI policy, there can not be any other resource with the same value under the same primary key policy.\" ;\n  rdfs:label \"Primary key constraint component\" ;\n  sh:labelTemplate \"The property {?predicate} is the primary key and URIs start with {?uriStart}\" ;\n  sh:message \"Violation of primary key constraint\" ;\n  sh:parameter dash:PrimaryKeyConstraintComponent-uriStart ;\n  sh:propertyValidator [\n      rdf:type sh:JSValidator ;\n      sh:jsFunctionName \"validatePrimaryKeyProperty\" ;\n      sh:jsLibrary dash:DASHJSLibrary ;\n    ] ;\n  sh:propertyValidator [\n      rdf:type sh:SPARQLSelectValidator ;\n      sh:prefixes <http://datashapes.org/dash> ;\n      sh:select \"\"\"SELECT DISTINCT $this\nWHERE {\n        FILTER (\n\t\t\t# Must have a value for the primary key\n\t\t\tNOT EXISTS { ?this $PATH ?any }\n\t\t\t||\n\t\t\t# Must have no more than one value for the primary key\n\t\t\tEXISTS {\n\t\t\t\t?this $PATH ?value1 .\n\t\t\t\t?this $PATH ?value2 .\n\t\t\t\tFILTER (?value1 != ?value2) .\n\t\t\t}\n\t\t\t||\n\t\t\t# The value of the primary key must align with the derived URI\n\t\t\tEXISTS {\n\t\t\t\t{\n        \t\t\t?this $PATH ?value .\n\t\t\t\t\tFILTER NOT EXISTS { ?this $PATH ?value2 . FILTER (?value != ?value2) }\n\t\t\t\t}\n        \t\tBIND (CONCAT($uriStart, ENCODE_FOR_URI(str(?value))) AS ?uri) .\n        \t\tFILTER (str(?this) != ?uri) .\n    \t\t}\n\t\t)\n}\"\"\" ;\n    ] ;\n  sh:targetClass sh:PropertyShape ;\n.\ndash:PrimaryKeyConstraintComponent-uriStart\n  rdf:type sh:Parameter ;\n  sh:path dash:uriStart ;\n  sh:datatype xsd:string ;\n  sh:description \"The start of the URIs of well-formed resources.\" ;\n  sh:name \"URI start\" ;\n.\ndash:QueryTestCase\n  rdf:type rdfs:Class ;\n  rdf:type sh:NodeShape ;\n  rdfs:comment \"A test case running a given SPARQL SELECT query and comparing its results with those stored as JSON Result Set in the expected result property.\" ;\n  rdfs:label \"Query test case\" ;\n  rdfs:subClassOf dash:TestCase ;\n  rdfs:subClassOf sh:SPARQLSelectExecutable ;\n  sh:property [\n      sh:path dash:expectedResult ;\n      sh:datatype xsd:string ;\n      sh:description \"The expected result set, as a JSON string.\" ;\n      sh:maxCount 1 ;\n      sh:minCount 1 ;\n      sh:name \"expected result\" ;\n    ] ;\n  sh:property [\n      sh:path sh:select ;\n      sh:datatype xsd:string ;\n      sh:description \"The SPARQL SELECT query to execute.\" ;\n      sh:maxCount 1 ;\n      sh:minCount 1 ;\n      sh:name \"SPARQL query\" ;\n    ] ;\n.\ndash:RDFQueryJSLibrary\n  rdf:type sh:JSLibrary ;\n  rdfs:label \"rdfQuery JavaScript Library\" ;\n  sh:jsLibraryURL \"http://datashapes.org/js/rdfquery.js\"^^xsd:anyURI ;\n.\ndash:RootClassConstraintComponent\n  rdf:type sh:ConstraintComponent ;\n  rdfs:comment \"A constraint component defining the parameter dash:rootClass, which restricts the values to be either the root class itself or one of its subclasses. This is typically used in conjunction with properties that have rdfs:Class as their type.\" ;\n  rdfs:label \"Root class constraint component\" ;\n  sh:labelTemplate \"Root class {$rootClass}\" ;\n  sh:message \"Value must be subclass of {$rootClass}\" ;\n  sh:parameter dash:RootClassConstraintComponent-rootClass ;\n  sh:targetClass sh:PropertyShape ;\n  sh:validator dash:hasRootClass ;\n  sh:validator [\n      rdf:type sh:JSValidator ;\n      sh:jsFunctionName \"validateRootClass\" ;\n      sh:jsLibrary dash:DASHJSLibrary ;\n    ] ;\n.\ndash:RootClassConstraintComponent-rootClass\n  rdf:type sh:Parameter ;\n  sh:path dash:rootClass ;\n  sh:class rdfs:Class ;\n  sh:description \"The root class.\" ;\n  sh:name \"root class\" ;\n  sh:nodeKind sh:IRI ;\n.\ndash:SPARQLUpdateSuggestionGenerator\n  rdf:type rdfs:Class ;\n  rdfs:comment \"\"\"A SuggestionGenerator based on a SPARQL UPDATE query (sh:update), producing an instance of dash:GraphUpdate. The INSERTs become dash:addedTriple and the DELETEs become dash:deletedTriple. The WHERE clause operates on the data graph with the pre-bound variables $subject, $predicate and $object, as well as the other pre-bound variables for the parameters of the constraint.\n\nIn many cases, there may be multiple possible suggestions to fix a problem. For example, with sh:maxLength there are many ways to slice a string. In those cases, the system will first iterate through the result variables from a SELECT query (sh:select) and apply these results as pre-bound variables into the UPDATE query.\"\"\" ;\n  rdfs:label \"SPARQL UPDATE suggestion generator\" ;\n  rdfs:subClassOf dash:SuggestionGenerator ;\n  rdfs:subClassOf sh:SPARQLSelectExecutable ;\n  rdfs:subClassOf sh:SPARQLUpdateExecutable ;\n.\ndash:StemConstraintComponent\n  rdf:type sh:ConstraintComponent ;\n  dash:staticConstraint \"true\"^^xsd:boolean ;\n  rdfs:comment \"A constraint component that can be used to verify that every value node is an IRI and the IRI starts with a given string value.\"@en ;\n  rdfs:label \"Stem constraint component\"@en ;\n  sh:message \"Value does not have stem {$stem}\" ;\n  sh:parameter dash:StemConstraintComponent-stem ;\n  sh:targetClass sh:Shape ;\n  sh:validator dash:hasStem ;\n  sh:validator [\n      rdf:type sh:JSValidator ;\n      sh:jsFunctionName \"validateStem\" ;\n      sh:jsLibrary dash:DASHJSLibrary ;\n    ] ;\n.\ndash:StemConstraintComponent-stem\n  rdf:type sh:Parameter ;\n  sh:path dash:stem ;\n  sh:datatype xsd:string ;\n.\ndash:StringOrLangString\n  rdf:type rdf:List ;\n  rdf:first xsd:string ;\n  rdf:rest (\n      rdf:langString\n    ) ;\n  rdfs:comment \"An rdf:List that can be used in property constraints as value for sh:or to indicate that all values of a property must be either xsd:string or rdf:langString.\" ;\n  rdfs:label \"String or langString\" ;\n.\ndash:SubSetOfConstraintComponent\n  rdf:type sh:ConstraintComponent ;\n  dash:localConstraint \"true\"^^xsd:boolean ;\n  rdfs:comment \"A constraint component that can be used to state that the set of value nodes must be a subset of the value of a given property.\" ;\n  rdfs:label \"Sub set of constraint component\" ;\n  sh:message \"Must be one of the values of {$subSetOf}\" ;\n  sh:parameter dash:SubSetOfConstraintComponent-subSetOf ;\n  sh:propertyValidator [\n      rdf:type sh:SPARQLAskValidator ;\n      sh:ask \"\"\"ASK {\n    $this $subSetOf $value .\n}\"\"\" ;\n      sh:prefixes <http://datashapes.org/dash> ;\n    ] ;\n  sh:targetClass sh:PropertyShape ;\n  sh:validator [\n      rdf:type sh:JSValidator ;\n      sh:jsFunctionName \"validateSubSetOf\" ;\n      sh:jsLibrary dash:DASHJSLibrary ;\n    ] ;\n.\ndash:SubSetOfConstraintComponent-subSetOf\n  rdf:type sh:Parameter ;\n  sh:path dash:subSetOf ;\n  sh:class rdf:Property ;\n  sh:description \"A property (of the focus node) that must (at least) have all values from the set of value nodes.\" ;\n.\ndash:SuccessResult\n  rdf:type rdfs:Class ;\n  rdfs:comment \"A result representing a successfully validated constraint.\" ;\n  rdfs:label \"Success result\" ;\n  rdfs:subClassOf sh:AbstractResult ;\n.\ndash:SuccessTestCaseResult\n  rdf:type rdfs:Class ;\n  rdfs:comment \"Represents a successful run of a test case.\" ;\n  rdfs:label \"Success test case result\" ;\n  rdfs:subClassOf dash:TestCaseResult ;\n.\ndash:Suggestion\n  rdf:type rdfs:Class ;\n  rdfs:comment \"Base class of suggestions that modify a graph to \\\"fix\\\" the source of a validation result.\" ;\n  rdfs:label \"Suggestion\" ;\n  rdfs:subClassOf rdfs:Resource ;\n.\ndash:SuggestionGenerator\n  rdf:type rdfs:Class ;\n  rdfs:comment \"Base class of objects that can generate suggestions (added or deleted triples) for a validation result of a given constraint component.\" ;\n  rdfs:label \"Suggestion generator\" ;\n  rdfs:subClassOf rdfs:Resource ;\n.\ndash:TestCase\n  rdf:type rdfs:Class ;\n  dash:abstract \"true\"^^xsd:boolean ;\n  rdfs:comment \"A test case to verify that a (SHACL-based) feature works as expected.\" ;\n  rdfs:label \"Test case\" ;\n  rdfs:subClassOf rdfs:Resource ;\n.\ndash:TestCaseResult\n  rdf:type rdfs:Class ;\n  rdfs:comment \"Base class for results produced by running test cases.\" ;\n  rdfs:label \"Test case result\" ;\n  rdfs:subClassOf sh:AbstractResult ;\n  sh:property [\n      sh:path dash:testCase ;\n      sh:class dash:TestCase ;\n      sh:description \"The dash:TestCase that was executed.\" ;\n      sh:maxCount 1 ;\n      sh:minCount 1 ;\n      sh:name \"test case\" ;\n    ] ;\n  sh:property [\n      sh:path dash:testGraph ;\n      sh:class rdfs:Resource ;\n      sh:description \"The graph containing the test case.\" ;\n      sh:maxCount 1 ;\n      sh:minCount 1 ;\n      sh:name \"test graph\" ;\n      sh:nodeKind sh:IRI ;\n    ] ;\n.\ndash:TestEnvironment\n  rdf:type rdfs:Class ;\n  dash:abstract \"true\"^^xsd:boolean ;\n  rdfs:comment \"Abstract base class for test environments, holding information on how to set up a test case.\" ;\n  rdfs:label \"Test environment\" ;\n  rdfs:subClassOf rdfs:Resource ;\n.\ndash:ValidationTestCase\n  rdf:type rdfs:Class ;\n  rdf:type sh:NodeShape ;\n  dash:abstract \"true\"^^xsd:boolean ;\n  rdfs:comment \"Abstract superclass for test cases concerning SHACL constraint validation. Future versions may add new kinds of validatin test cases, e.g. to validate a single resource only.\" ;\n  rdfs:label \"Validation test case\" ;\n  rdfs:subClassOf dash:TestCase ;\n  sh:property [\n      sh:path dash:expectedResult ;\n      sh:class sh:ValidationReport ;\n      sh:description \"The expected validation report.\" ;\n      sh:name \"expected result\" ;\n    ] ;\n.\ndash:abstract\n  rdf:type rdf:Property ;\n  rdfs:comment \"Indicates that a class is \\\"abstract\\\" and cannot be used in asserted rdf:type triples. Only non-abstract subclasses of abstract classes should be instantiated directly.\" ;\n  rdfs:domain rdfs:Class ;\n  rdfs:label \"abstract\" ;\n  rdfs:range xsd:boolean ;\n.\ndash:addedTriple\n  rdf:type rdf:Property ;\n  rdfs:comment \"May link a dash:GraphUpdate with one or more triples (represented as instances of rdf:Statement) that should be added to fix the source of the result.\" ;\n  rdfs:domain dash:GraphUpdate ;\n  rdfs:label \"added triple\" ;\n  rdfs:range rdf:Statement ;\n.\ndash:cachable\n  rdf:type rdf:Property ;\n  rdfs:comment \"If set to true then the results of the SHACL function can be cached in between invocations with the same arguments. In other words, they are stateless and do not depend on triples in any graph, or the current time stamp etc.\" ;\n  rdfs:domain sh:Function ;\n  rdfs:label \"cachable\" ;\n  rdfs:range xsd:boolean ;\n.\ndash:closedByTypes\n  rdf:type rdf:Property ;\n  rdfs:label \"closed by types\" ;\n.\ndash:coExistsWith\n  rdf:type rdf:Property ;\n  rdfs:comment \"Specifies a property that must have a value whenever the property path has a value, and must have no value whenever the property path has no value.\" ;\n  rdfs:label \"co-exists with\" ;\n  rdfs:range rdf:Property ;\n.\ndash:composite\n  rdf:type rdf:Property ;\n  rdfs:comment \"Can be used to indicate that a property/path represented by a property constraint represents a composite relationship. In a composite relationship, the life cycle of a \\\"child\\\" object (value of the property/path) depends on the \\\"parent\\\" object (focus node). If the parent gets deleted, then the child objects should be deleted, too. Tools may use dash:composite (if set to true) to implement cascading delete operations.\" ;\n  rdfs:domain sh:PropertyShape ;\n  rdfs:label \"composite\" ;\n  rdfs:range xsd:boolean ;\n.\ndash:defaultValueType\n  rdf:type rdf:Property ;\n  rdfs:comment \"\"\"\n\t\tLinks a property with a default value type.\n\t\tThe default value type is assumed to be the <code>rdf:type</code> of values of the property\n\t\tthat declare no type on their own.\n\t\tAn example use of <code>sh:defaultValueType</code> is <code>sh:property</code>,\n\t\tthe values of which are assumed to be instances of <code>sh:PropertyShape</code>\n\t\teven if they are untyped (blank) nodes.\n\t\t\"\"\"^^rdf:HTML ;\n  rdfs:label \"default value type\" ;\n  rdfs:range rdfs:Class ;\n  owl:versionInfo \"Note this property may get removed in future versions. It is a left-over from a previous design in SHACL.\" ;\n.\ndash:deletedTriple\n  rdf:type rdf:Property ;\n  rdfs:comment \"May link a dash:GraphUpdate result with one or more triples (represented as instances of rdf:Statement) that should be deleted to fix the source of the result.\" ;\n  rdfs:domain dash:GraphUpdate ;\n  rdfs:label \"deleted triple\" ;\n  rdfs:range rdf:Statement ;\n.\ndash:expectedResult\n  rdf:type rdf:Property ;\n  rdfs:comment \"The expected result(s) of a test case. The value range of this property is different for each kind of test cases.\" ;\n  rdfs:domain dash:TestCase ;\n  rdfs:label \"expected result\" ;\n.\ndash:fixed\n  rdf:type rdf:Property ;\n  rdfs:comment \"Can be used to mark that certain validation results have already been fixed.\" ;\n  rdfs:domain sh:ValidationResult ;\n  rdfs:label \"fixed\" ;\n  rdfs:range xsd:boolean ;\n.\ndash:hasClass\n  rdf:type sh:SPARQLAskValidator ;\n  rdfs:label \"has class\" ;\n  sh:ask \"\"\"\n\t\tASK {\n\t\t\t$value rdf:type/rdfs:subClassOf* $class .\n\t\t}\n\t\t\"\"\" ;\n  sh:message \"Value does not have class {$class}\" ;\n  sh:prefixes <http://datashapes.org/dash> ;\n.\ndash:hasMaxExclusive\n  rdf:type sh:SPARQLAskValidator ;\n  rdfs:comment \"Checks whether a given node (?value) has value less than (<) the provided ?maxExclusive. Returns false if this cannot be determined, e.g. because values do not have comparable types.\" ;\n  rdfs:label \"has max exclusive\" ;\n  sh:ask \"ASK { FILTER ($value < $maxExclusive) }\" ;\n  sh:prefixes <http://datashapes.org/dash> ;\n.\ndash:hasMaxInclusive\n  rdf:type sh:SPARQLAskValidator ;\n  rdfs:comment \"Checks whether a given node (?value) has value less than or equal to (<=) the provided ?maxInclusive. Returns false if this cannot be determined, e.g. because values do not have comparable types.\" ;\n  rdfs:label \"has max inclusive\" ;\n  sh:ask \"ASK { FILTER ($value <= $maxInclusive) }\" ;\n  sh:prefixes <http://datashapes.org/dash> ;\n.\ndash:hasMaxLength\n  rdf:type sh:SPARQLAskValidator ;\n  rdfs:comment \"Checks whether a given string (?value) has a length within a given maximum string length.\" ;\n  rdfs:label \"has max length\" ;\n  sh:ask \"\"\"\n\t\tASK {\n\t\t\tFILTER (STRLEN(str($value)) <= $maxLength) .\n\t\t}\n\t\t\"\"\" ;\n  sh:prefixes <http://datashapes.org/dash> ;\n.\ndash:hasMinExclusive\n  rdf:type sh:SPARQLAskValidator ;\n  rdfs:comment \"Checks whether a given node (?value) has value greater than (>) the provided ?minExclusive. Returns false if this cannot be determined, e.g. because values do not have comparable types.\" ;\n  rdfs:label \"has min exclusive\" ;\n  sh:ask \"ASK { FILTER ($value > $minExclusive) }\" ;\n  sh:prefixes <http://datashapes.org/dash> ;\n.\ndash:hasMinInclusive\n  rdf:type sh:SPARQLAskValidator ;\n  rdfs:comment \"Checks whether a given node (?value) has value greater than or equal to (>=) the provided ?minInclusive. Returns false if this cannot be determined, e.g. because values do not have comparable types.\" ;\n  rdfs:label \"has min inclusive\" ;\n  sh:ask \"ASK { FILTER ($value >= $minInclusive) }\" ;\n  sh:prefixes <http://datashapes.org/dash> ;\n.\ndash:hasMinLength\n  rdf:type sh:SPARQLAskValidator ;\n  rdfs:comment \"Checks whether a given string (?value) has a length within a given minimum string length.\" ;\n  rdfs:label \"has min length\" ;\n  sh:ask \"\"\"\n\t\tASK {\n\t\t\tFILTER (STRLEN(str($value)) >= $minLength) .\n\t\t}\n\t\t\"\"\" ;\n  sh:prefixes <http://datashapes.org/dash> ;\n.\ndash:hasNodeKind\n  rdf:type sh:SPARQLAskValidator ;\n  rdfs:comment \"Checks whether a given node (?value) has a given sh:NodeKind (?nodeKind). For example, sh:hasNodeKind(42, sh:Literal) = true.\" ;\n  rdfs:label \"has node kind\" ;\n  sh:ask \"\"\"\n\t\tASK {\n\t\t\tFILTER ((isIRI($value) && $nodeKind IN ( sh:IRI, sh:BlankNodeOrIRI, sh:IRIOrLiteral ) ) ||\n\t\t\t\t(isLiteral($value) && $nodeKind IN ( sh:Literal, sh:BlankNodeOrLiteral, sh:IRIOrLiteral ) ) ||\n\t\t\t\t(isBlank($value)   && $nodeKind IN ( sh:BlankNode, sh:BlankNodeOrIRI, sh:BlankNodeOrLiteral ) )) .\n\t\t}\n\t\t\"\"\" ;\n  sh:prefixes <http://datashapes.org/dash> ;\n.\ndash:hasPattern\n  rdf:type sh:SPARQLAskValidator ;\n  rdfs:comment \"Checks whether the string representation of a given node (?value) matches a given regular expression (?pattern). Returns false if the value is a blank node.\" ;\n  rdfs:label \"has pattern\" ;\n  sh:ask \"ASK { FILTER (!isBlank($value) && IF(bound($flags), regex(str($value), $pattern, $flags), regex(str($value), $pattern))) }\" ;\n  sh:prefixes <http://datashapes.org/dash> ;\n.\ndash:hasRootClass\n  rdf:type sh:SPARQLAskValidator ;\n  rdfs:label \"has root class\" ;\n  sh:ask \"\"\"ASK {\n    $value rdfs:subClassOf* $rootClass .\n}\"\"\" ;\n  sh:prefixes <http://datashapes.org/dash> ;\n.\ndash:hasStem\n  rdf:type sh:SPARQLAskValidator ;\n  rdfs:comment \"Checks whether a given node is an IRI starting with a given stem.\" ;\n  rdfs:label \"has stem\" ;\n  sh:ask \"ASK { FILTER (isIRI($value) && STRSTARTS(str($value), $stem)) }\" ;\n  sh:prefixes <http://datashapes.org/dash> ;\n.\ndash:hasValueWithClass\n  rdf:type rdf:Property ;\n  rdfs:comment \"Specifies a constraint that at least one of the value nodes must be an instance of a given class.\" ;\n  rdfs:label \"has value with class\" ;\n  rdfs:range rdfs:Class ;\n.\ndash:height\n  rdf:type rdf:Property ;\n  rdfs:comment \"The height.\" ;\n  rdfs:label \"height\" ;\n  rdfs:range xsd:integer ;\n.\ndash:isDeactivated\n  rdf:type sh:SPARQLFunction ;\n  rdfs:comment \"Checks whether a given shape or constraint has been marked as \\\"deactivated\\\" using sh:deactivated.\" ;\n  rdfs:label \"is deactivated\" ;\n  sh:ask \"\"\"ASK {\n    ?constraintOrShape sh:deactivated true .\n}\"\"\" ;\n  sh:parameter [\n      sh:path dash:constraintOrShape ;\n      sh:description \"The sh:Constraint or sh:Shape to test.\" ;\n      sh:name \"constraint or shape\" ;\n    ] ;\n  sh:prefixes <http://datashapes.org/dash> ;\n  sh:returnType xsd:boolean ;\n.\ndash:isIn\n  rdf:type sh:SPARQLAskValidator ;\n  rdfs:label \"is in\" ;\n  sh:ask \"\"\"\n\t\tASK {\n\t\t\tGRAPH $shapesGraph {\n\t\t\t\t$in (rdf:rest*)/rdf:first $value .\n\t\t\t}\n\t\t}\n\t\t\"\"\" ;\n  sh:prefixes <http://datashapes.org/dash> ;\n.\ndash:isLanguageIn\n  rdf:type sh:SPARQLAskValidator ;\n  rdfs:label \"is language in\" ;\n  sh:ask \"\"\"\n\t\tASK {\n\t\t\tBIND (lang($value) AS ?valueLang) .\n\t\t\tFILTER EXISTS {\n\t\t\t\tGRAPH $shapesGraph {\n\t\t\t\t\t$languageIn (rdf:rest*)/rdf:first ?lang .\n\t\t\t\t    FILTER (langMatches(?valueLang, ?lang))\n\t\t\t\t} }\n\t\t}\n\t\t\"\"\" ;\n  sh:prefixes <http://datashapes.org/dash> ;\n.\ndash:isNodeKindBlankNode\n  rdf:type sh:SPARQLFunction ;\n  dash:cachable \"true\"^^xsd:boolean ;\n  rdfs:comment \"Checks if a given sh:NodeKind is one that includes BlankNodes.\" ;\n  rdfs:label \"is NodeKind BlankNode\" ;\n  sh:ask \"\"\"ASK {\n\tFILTER ($nodeKind IN ( sh:BlankNode, sh:BlankNodeOrIRI, sh:BlankNodeOrLiteral ))\n}\"\"\" ;\n  sh:parameter [\n      sh:path dash:nodeKind ;\n      sh:class sh:NodeKind ;\n      sh:description \"The sh:NodeKind to check.\" ;\n      sh:name \"node kind\" ;\n      sh:nodeKind sh:IRI ;\n    ] ;\n  sh:prefixes <http://datashapes.org/dash> ;\n  sh:returnType xsd:boolean ;\n.\ndash:isNodeKindIRI\n  rdf:type sh:SPARQLFunction ;\n  dash:cachable \"true\"^^xsd:boolean ;\n  rdfs:comment \"Checks if a given sh:NodeKind is one that includes IRIs.\" ;\n  rdfs:label \"is NodeKind IRI\" ;\n  sh:ask \"\"\"ASK {\n\tFILTER ($nodeKind IN ( sh:IRI, sh:BlankNodeOrIRI, sh:IRIOrLiteral ))\n}\"\"\" ;\n  sh:parameter [\n      sh:path dash:nodeKind ;\n      sh:class sh:NodeKind ;\n      sh:description \"The sh:NodeKind to check.\" ;\n      sh:name \"node kind\" ;\n      sh:nodeKind sh:IRI ;\n    ] ;\n  sh:prefixes <http://datashapes.org/dash> ;\n  sh:returnType xsd:boolean ;\n.\ndash:isNodeKindLiteral\n  rdf:type sh:SPARQLFunction ;\n  dash:cachable \"true\"^^xsd:boolean ;\n  rdfs:comment \"Checks if a given sh:NodeKind is one that includes Literals.\" ;\n  rdfs:label \"is NodeKind Literal\" ;\n  sh:ask \"\"\"ASK {\n\tFILTER ($nodeKind IN ( sh:Literal, sh:BlankNodeOrLiteral, sh:IRIOrLiteral ))\n}\"\"\" ;\n  sh:parameter [\n      sh:path dash:nodeKind ;\n      sh:class sh:NodeKind ;\n      sh:description \"The sh:NodeKind to check.\" ;\n      sh:name \"node kind\" ;\n      sh:nodeKind sh:IRI ;\n    ] ;\n  sh:prefixes <http://datashapes.org/dash> ;\n  sh:returnType xsd:boolean ;\n.\ndash:localConstraint\n  rdf:type rdf:Property ;\n  rdfs:comment \"\"\"Can be set to true for those constraint components where the validation does not require to visit any other triples than the shape definitions and the direct property values of the focus node mentioned in the property constraints. Examples of this include sh:minCount and sh:hasValue.\n\nConstraint components that are marked as such can be optimized by engines, e.g. they can be evaluated client-side at form submission time, without having to make a round-trip to a server, assuming the client has downloaded a complete snapshot of the resource.\n\nAny component marked with dash:staticConstraint is also a dash:localConstraint.\"\"\" ;\n  rdfs:domain sh:ConstraintComponent ;\n  rdfs:label \"local constraint\" ;\n  rdfs:range xsd:boolean ;\n.\ndash:propertySuggestionGenerator\n  rdf:type rdf:Property ;\n  rdfs:comment \"Links the constraint component with instances of dash:SuggestionGenerator that may be used to produce suggestions for a given validation result that was produced by a property constraint.\" ;\n  rdfs:domain sh:ConstraintComponent ;\n  rdfs:label \"property suggestion generator\" ;\n  rdfs:range dash:SuggestionGenerator ;\n.\ndash:rootClass\n  rdf:type rdf:Property ;\n  rdfs:label \"root class\" ;\n.\ndash:staticConstraint\n  rdf:type rdf:Property ;\n  rdfs:comment \"\"\"Can be set to true for those constraint components where the validation does not require to visit any other triples than the parameters. Examples of this include sh:datatype or sh:nodeKind, where no further triples need to be queried to determine the result.\n\nConstraint components that are marked as such can be optimized by engines, e.g. they can be evaluated client-side at form submission time, without having to make a round-trip to a server.\"\"\" ;\n  rdfs:domain sh:ConstraintComponent ;\n  rdfs:label \"static constraint\" ;\n  rdfs:range xsd:boolean ;\n.\ndash:stem\n  rdf:type rdf:Property ;\n  rdfs:comment \"Specifies a string value that the IRI of the value nodes must start with.\"@en ;\n  rdfs:label \"stem\"@en ;\n  rdfs:range xsd:string ;\n.\ndash:subSetOf\n  rdf:type rdf:Property ;\n  rdfs:label \"sub set of\" ;\n.\ndash:suggestion\n  rdf:type rdf:Property ;\n  rdfs:comment \"Can be used to link a validation result with one or more suggestions on how to fix the underlying issue.\" ;\n  rdfs:domain sh:ValidationResult ;\n  rdfs:label \"suggestion\" ;\n  rdfs:range dash:Suggestion ;\n.\ndash:suggestionGenerator\n  rdf:type rdf:Property ;\n  rdfs:comment \"Links a sh:SPARQLConstraint with instances of dash:SuggestionGenerator that may be used to produce suggestions for a given validation result that was produced by the constraint.\" ;\n  rdfs:domain sh:SPARQLConstraint ;\n  rdfs:label \"suggestion generator\" ;\n  rdfs:range dash:SuggestionGenerator ;\n.\ndash:suggestionGroup\n  rdf:type rdf:Property ;\n  rdfs:comment \"Can be used to link a suggestion with the group identifier to which it belongs. By default this is a link to the dash:SuggestionGenerator, but in principle this could be any value.\" ;\n  rdfs:domain dash:Suggestion ;\n  rdfs:label \"suggestion\" ;\n.\ndash:testEnvironment\n  rdf:type rdf:Property ;\n  rdfs:comment \"Can be used by TestCases to point at a resource with information on how to set up the execution environment prior to execution.\" ;\n  rdfs:domain dash:TestCase ;\n  rdfs:label \"test environment\" ;\n  rdfs:range dash:TestEnvironment ;\n.\ndash:testModifiesEnvironment\n  rdf:type rdf:Property ;\n  rdfs:comment \"Indicates whether this test modifies the specified dash:testEnvironment. If set to true then a test runner can make sure to wipe out the previous environment, while leaving it false (or undefined) means that the test runner can reuse the environment from the previous test case. As setting up and tearing down tests is sometimes slow, this flag can significantly accelerate test execution.\" ;\n  rdfs:domain dash:TestCase ;\n  rdfs:label \"test modifies environment\" ;\n  rdfs:range xsd:boolean ;\n.\ndash:toString\n  rdf:type sh:JSFunction ;\n  rdf:type sh:SPARQLFunction ;\n  dash:cachable \"true\"^^xsd:boolean ;\n  rdfs:comment \"Returns a literal with datatype xsd:string that has the input value as its string. If the input value is an (URI) resource then its URI will be used.\" ;\n  rdfs:label \"to string\" ;\n  sh:jsFunctionName \"dash_toString\" ;\n  sh:jsLibrary dash:DASHJSLibrary ;\n  sh:labelTemplate \"Convert {$arg} to xsd:string\" ;\n  sh:parameter [\n      sh:path dash:arg ;\n      sh:description \"The input value.\" ;\n      sh:name \"arg\" ;\n      sh:nodeKind sh:IRIOrLiteral ;\n    ] ;\n  sh:prefixes <http://datashapes.org/dash> ;\n  sh:returnType xsd:string ;\n  sh:select \"\"\"SELECT (xsd:string($arg) AS ?result)\nWHERE {\n}\"\"\" ;\n.\ndash:validateShapes\n  rdf:type rdf:Property ;\n  rdfs:comment \"True to also validate the shapes itself (i.e. parameter declarations).\" ;\n  rdfs:domain dash:GraphValidationTestCase ;\n  rdfs:label \"validate shapes\" ;\n  rdfs:range xsd:boolean ;\n.\ndash:valueCount\n  rdf:type sh:SPARQLFunction ;\n  rdfs:comment \"Computes the number of objects for a given subject/predicate combination.\" ;\n  rdfs:label \"value count\" ;\n  sh:parameter [\n      sh:path dash:predicate ;\n      sh:class rdfs:Resource ;\n      sh:description \"The predicate to get the number of objects of.\" ;\n      sh:name \"predicate\" ;\n      sh:order 1 ;\n    ] ;\n  sh:parameter [\n      sh:path dash:subject ;\n      sh:class rdfs:Resource ;\n      sh:description \"The subject to get the number of objects of.\" ;\n      sh:name \"subject\" ;\n      sh:order 0 ;\n    ] ;\n  sh:prefixes <http://datashapes.org/dash> ;\n  sh:returnType xsd:integer ;\n  sh:select \"\"\"\n\t\tSELECT (COUNT(?object) AS ?result)\n\t\tWHERE {\n    \t\t$subject $predicate ?object .\n\t\t}\n\"\"\" ;\n.\ndash:width\n  rdf:type rdf:Property ;\n  rdfs:comment \"The width.\" ;\n  rdfs:label \"width\" ;\n  rdfs:range xsd:integer ;\n.\ndash:x\n  rdf:type rdf:Property ;\n  rdfs:comment \"The x position.\" ;\n  rdfs:label \"x\" ;\n  rdfs:range xsd:integer ;\n.\ndash:y\n  rdf:type rdf:Property ;\n  rdfs:comment \"The y position.\" ;\n  rdfs:label \"y\" ;\n  rdfs:range xsd:integer ;\n.\nowl:Class\n  rdf:type rdfs:Class ;\n  rdfs:subClassOf rdfs:Class ;\n.\nsh:AndConstraintComponent\n  sh:targetClass sh:Shape ;\n  sh:validator [\n      rdf:type sh:JSValidator ;\n      sh:jsFunctionName \"validateAnd\" ;\n      sh:jsLibrary dash:DASHJSLibrary ;\n    ] ;\n.\nsh:ClassConstraintComponent\n  sh:targetClass sh:Shape ;\n  sh:validator dash:hasClass ;\n  sh:validator [\n      rdf:type sh:JSValidator ;\n      sh:jsFunctionName \"validateClass\" ;\n      sh:jsLibrary dash:DASHJSLibrary ;\n    ] ;\n.\nsh:ClosedConstraintComponent\n  dash:localConstraint \"true\"^^xsd:boolean ;\n  sh:nodeValidator [\n      rdf:type sh:SPARQLSelectValidator ;\n      sh:message \"Predicate {?path} is not allowed (closed shape)\" ;\n      sh:prefixes <http://datashapes.org/dash> ;\n      sh:select \"\"\"\n\t\tSELECT $this (?predicate AS ?path) ?value\n\t\tWHERE {\n\t\t\t{\n\t\t\t\tFILTER ($closed) .\n\t\t\t}\n\t\t\t$this ?predicate ?value .\n\t\t\tFILTER (NOT EXISTS {\n\t\t\t\tGRAPH $shapesGraph {\n\t\t\t\t\t$currentShape sh:property/sh:path ?predicate .\n\t\t\t\t}\n\t\t\t} && (!bound($ignoredProperties) || NOT EXISTS {\n\t\t\t\tGRAPH $shapesGraph {\n\t\t\t\t\t$ignoredProperties rdf:rest*/rdf:first ?predicate .\n\t\t\t\t}\n\t\t\t}))\n\t\t}\n\"\"\" ;\n    ] ;\n  sh:targetClass sh:NodeShape ;\n  sh:validator [\n      rdf:type sh:JSValidator ;\n      sh:jsFunctionName \"validateClosed\" ;\n      sh:jsLibrary dash:DASHJSLibrary ;\n      sh:message \"Predicate is not allowed (closed shape)\" ;\n    ] ;\n.\nsh:DatatypeConstraintComponent\n  dash:staticConstraint \"true\"^^xsd:boolean ;\n  sh:message \"Value does not have datatype {$datatype}\" ;\n  sh:targetClass sh:PropertyShape ;\n  sh:validator [\n      rdf:type sh:JSValidator ;\n      sh:jsFunctionName \"validateDatatype\" ;\n      sh:jsLibrary dash:DASHJSLibrary ;\n    ] ;\n.\nsh:DerivedValuesConstraintComponent\n  sh:targetClass sh:PropertyShape ;\n.\nsh:DisjointConstraintComponent\n  dash:localConstraint \"true\"^^xsd:boolean ;\n  sh:targetClass sh:Shape ;\n  sh:validator [\n      rdf:type sh:JSValidator ;\n      sh:jsFunctionName \"validateDisjoint\" ;\n      sh:jsLibrary dash:DASHJSLibrary ;\n      sh:message \"Value node must not also be one of the values of {$disjoint}\" ;\n    ] ;\n  sh:validator [\n      rdf:type sh:SPARQLAskValidator ;\n      sh:ask \"\"\"\n\t\tASK {\n\t\t\tFILTER NOT EXISTS {\n\t\t\t\t$this $disjoint $value .\n\t\t\t}\n\t\t}\n\t\t\"\"\" ;\n      sh:message \"Property must not share any values with {$disjoint}\" ;\n      sh:prefixes <http://datashapes.org/dash> ;\n    ] ;\n.\nsh:EqualsConstraintComponent\n  dash:localConstraint \"true\"^^xsd:boolean ;\n  sh:message \"Must have same values as {$equals}\" ;\n  sh:nodeValidator [\n      rdf:type sh:SPARQLSelectValidator ;\n      sh:prefixes <http://datashapes.org/dash> ;\n      sh:select \"\"\"\n\t\tSELECT DISTINCT $this ?value\n\t\tWHERE {\n\t\t\t{\n\t\t\t\tFILTER NOT EXISTS { $this $equals $this }\n\t\t\t\tBIND ($this AS ?value) .\n\t\t\t}\n\t\t\tUNION\n\t\t\t{\n\t\t\t\t$this $equals ?value .\n\t\t\t\tFILTER (?value != $this) .\n\t\t\t}\n\t\t}\n\t\t\"\"\" ;\n    ] ;\n  sh:nodeValidator [\n      rdf:type sh:JSValidator ;\n      sh:jsFunctionName \"validateEqualsNode\" ;\n      sh:jsLibrary dash:DASHJSLibrary ;\n    ] ;\n  sh:propertyValidator [\n      rdf:type sh:JSValidator ;\n      sh:jsFunctionName \"validateEqualsProperty\" ;\n      sh:jsLibrary dash:DASHJSLibrary ;\n    ] ;\n  sh:propertyValidator [\n      rdf:type sh:SPARQLSelectValidator ;\n      sh:prefixes <http://datashapes.org/dash> ;\n      sh:select \"\"\"\n\t\tSELECT DISTINCT $this ?value\n\t\tWHERE {\n\t\t\t{\n\t\t\t\t$this $PATH ?value .\n\t\t\t\tMINUS {\n\t\t\t\t\t$this $equals ?value .\n\t\t\t\t}\n\t\t\t}\n\t\t\tUNION\n\t\t\t{\n\t\t\t\t$this $equals ?value .\n\t\t\t\tMINUS {\n\t\t\t\t\t$this $PATH ?value .\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\"\"\" ;\n    ] ;\n  sh:targetClass sh:Shape ;\n.\nsh:Function\n  sh:property [\n      sh:path dash:cachable ;\n      sh:datatype xsd:boolean ;\n      sh:description \"True to indicate that this function will always return the same values for the same combination of arguments, regardless of the query graphs. Engines can use this information to cache and reuse previous function calls.\" ;\n      sh:maxCount 1 ;\n      sh:name \"cachable\" ;\n    ] ;\n.\nsh:HasValueConstraintComponent\n  dash:localConstraint \"true\"^^xsd:boolean ;\n  sh:nodeValidator [\n      rdf:type sh:JSValidator ;\n      sh:jsFunctionName \"validateHasValueNode\" ;\n      sh:jsLibrary dash:DASHJSLibrary ;\n      sh:message \"Value must be {$hasValue}\" ;\n    ] ;\n  sh:nodeValidator [\n      rdf:type sh:SPARQLAskValidator ;\n      sh:ask \"\"\"ASK {\n    FILTER ($value = $hasValue)\n}\"\"\" ;\n      sh:message \"Value must be {$hasValue}\" ;\n      sh:prefixes <http://datashapes.org/dash> ;\n    ] ;\n  sh:propertyValidator [\n      rdf:type sh:JSValidator ;\n      sh:jsFunctionName \"validateHasValueProperty\" ;\n      sh:jsLibrary dash:DASHJSLibrary ;\n      sh:message \"Missing expected value {$hasValue}\" ;\n    ] ;\n  sh:propertyValidator [\n      rdf:type sh:SPARQLSelectValidator ;\n      sh:message \"Missing expected value {$hasValue}\" ;\n      sh:prefixes <http://datashapes.org/dash> ;\n      sh:select \"\"\"\n\t\tSELECT $this\n\t\tWHERE {\n\t\t\tFILTER NOT EXISTS { $this $PATH $hasValue }\n\t\t}\n\t\t\"\"\" ;\n    ] ;\n  sh:targetClass sh:Shape ;\n.\nsh:InConstraintComponent\n  dash:localConstraint \"true\"^^xsd:boolean ;\n  sh:message \"Value is not in {$in}\" ;\n  sh:targetClass sh:Shape ;\n  sh:validator dash:isIn ;\n  sh:validator [\n      rdf:type sh:JSValidator ;\n      sh:jsFunctionName \"validateIn\" ;\n      sh:jsLibrary dash:DASHJSLibrary ;\n    ] ;\n.\nsh:LanguageInConstraintComponent\n  dash:localConstraint \"true\"^^xsd:boolean ;\n  sh:message \"Language does not match any of {$languageIn}\" ;\n  sh:targetClass sh:Shape ;\n  sh:validator dash:isLanguageIn ;\n  sh:validator [\n      rdf:type sh:JSValidator ;\n      sh:jsFunctionName \"validateLanguageIn\" ;\n      sh:jsLibrary dash:DASHJSLibrary ;\n    ] ;\n.\nsh:LessThanConstraintComponent\n  dash:localConstraint \"true\"^^xsd:boolean ;\n  sh:message \"Value is not < value of {$lessThan}\" ;\n  sh:propertyValidator [\n      rdf:type sh:JSValidator ;\n      sh:jsFunctionName \"validateLessThanProperty\" ;\n      sh:jsLibrary dash:DASHJSLibrary ;\n    ] ;\n  sh:propertyValidator [\n      rdf:type sh:SPARQLSelectValidator ;\n      sh:prefixes <http://datashapes.org/dash> ;\n      sh:select \"\"\"\n\t\tSELECT $this ?value\n\t\tWHERE {\n\t\t\t$this $PATH ?value .\n\t\t\t$this $lessThan ?otherValue .\n\t\t\tBIND (?value < ?otherValue AS ?result) .\n\t\t\tFILTER (!bound(?result) || !(?result)) .\n\t\t}\n\t\t\"\"\" ;\n    ] ;\n  sh:targetClass sh:PropertyShape ;\n.\nsh:LessThanOrEqualsConstraintComponent\n  dash:localConstraint \"true\"^^xsd:boolean ;\n  sh:message \"Value is not <= value of {$lessThanOrEquals}\" ;\n  sh:propertyValidator [\n      rdf:type sh:JSValidator ;\n      sh:jsFunctionName \"validateLessThanOrEqualsProperty\" ;\n      sh:jsLibrary dash:DASHJSLibrary ;\n    ] ;\n  sh:propertyValidator [\n      rdf:type sh:SPARQLSelectValidator ;\n      sh:prefixes <http://datashapes.org/dash> ;\n      sh:select \"\"\"\n\t\tSELECT DISTINCT $this ?value\n\t\tWHERE {\n\t\t\t$this $PATH ?value .\n\t\t\t$this $lessThanOrEquals ?otherValue .\n\t\t\tBIND (?value <= ?otherValue AS ?result) .\n\t\t\tFILTER (!bound(?result) || !(?result)) .\n\t\t}\n\"\"\" ;\n    ] ;\n  sh:targetClass sh:PropertyShape ;\n.\nsh:MaxCountConstraintComponent\n  dash:localConstraint \"true\"^^xsd:boolean ;\n  sh:message \"More than {$maxCount} values\" ;\n  sh:propertyValidator [\n      rdf:type sh:JSValidator ;\n      sh:jsFunctionName \"validateMaxCountProperty\" ;\n      sh:jsLibrary dash:DASHJSLibrary ;\n    ] ;\n  sh:propertyValidator [\n      rdf:type sh:SPARQLSelectValidator ;\n      sh:prefixes <http://datashapes.org/dash> ;\n      sh:select \"\"\"\n\t\tSELECT $this\n\t\tWHERE {\n\t\t\t$this $PATH ?value .\n\t\t}\n\t\tGROUP BY $this\n\t\tHAVING (COUNT(DISTINCT ?value) > $maxCount)\n\t\t\"\"\" ;\n    ] ;\n  sh:targetClass sh:PropertyShape ;\n.\nsh:MaxExclusiveConstraintComponent\n  dash:staticConstraint \"true\"^^xsd:boolean ;\n  sh:message \"Value is not < {$maxExclusive}\" ;\n  sh:targetClass sh:Shape ;\n  sh:validator dash:hasMaxExclusive ;\n  sh:validator [\n      rdf:type sh:JSValidator ;\n      sh:jsFunctionName \"validateMaxExclusive\" ;\n      sh:jsLibrary dash:DASHJSLibrary ;\n    ] ;\n.\nsh:MaxInclusiveConstraintComponent\n  dash:staticConstraint \"true\"^^xsd:boolean ;\n  sh:message \"Value is not <= {$maxInclusive}\" ;\n  sh:targetClass sh:Shape ;\n  sh:validator dash:hasMaxInclusive ;\n  sh:validator [\n      rdf:type sh:JSValidator ;\n      sh:jsFunctionName \"validateMaxInclusive\" ;\n      sh:jsLibrary dash:DASHJSLibrary ;\n    ] ;\n.\nsh:MaxLengthConstraintComponent\n  dash:staticConstraint \"true\"^^xsd:boolean ;\n  sh:message \"Value has more than {$maxLength} characters\" ;\n  sh:targetClass sh:Shape ;\n  sh:validator dash:hasMaxLength ;\n  sh:validator [\n      rdf:type sh:JSValidator ;\n      sh:jsFunctionName \"validateMaxLength\" ;\n      sh:jsLibrary dash:DASHJSLibrary ;\n    ] ;\n.\nsh:MinCountConstraintComponent\n  dash:localConstraint \"true\"^^xsd:boolean ;\n  sh:message \"Less than {$minCount} values\" ;\n  sh:propertyValidator [\n      rdf:type sh:JSValidator ;\n      sh:jsFunctionName \"validateMinCountProperty\" ;\n      sh:jsLibrary dash:DASHJSLibrary ;\n    ] ;\n  sh:propertyValidator [\n      rdf:type sh:SPARQLSelectValidator ;\n      sh:prefixes <http://datashapes.org/dash> ;\n      sh:select \"\"\"\n\t\tSELECT $this\n\t\tWHERE {\n\t\t\tOPTIONAL {\n\t\t\t\t$this $PATH ?value .\n\t\t\t}\n\t\t}\n\t\tGROUP BY $this\n\t\tHAVING (COUNT(DISTINCT ?value) < $minCount)\n\t\t\"\"\" ;\n    ] ;\n  sh:targetClass sh:PropertyShape ;\n.\nsh:MinExclusiveConstraintComponent\n  dash:staticConstraint \"true\"^^xsd:boolean ;\n  sh:message \"Value is not > {$minExclusive}\" ;\n  sh:targetClass sh:Shape ;\n  sh:validator dash:hasMinExclusive ;\n  sh:validator [\n      rdf:type sh:JSValidator ;\n      sh:jsFunctionName \"validateMinExclusive\" ;\n      sh:jsLibrary dash:DASHJSLibrary ;\n    ] ;\n.\nsh:MinInclusiveConstraintComponent\n  dash:staticConstraint \"true\"^^xsd:boolean ;\n  sh:message \"Value is not >= {$minInclusive}\" ;\n  sh:targetClass sh:Shape ;\n  sh:validator dash:hasMinInclusive ;\n  sh:validator [\n      rdf:type sh:JSValidator ;\n      sh:jsFunctionName \"validateMinInclusive\" ;\n      sh:jsLibrary dash:DASHJSLibrary ;\n    ] ;\n.\nsh:MinLengthConstraintComponent\n  dash:staticConstraint \"true\"^^xsd:boolean ;\n  sh:message \"Value has less than {$minLength} characters\" ;\n  sh:targetClass sh:Shape ;\n  sh:validator dash:hasMinLength ;\n  sh:validator [\n      rdf:type sh:JSValidator ;\n      sh:jsFunctionName \"validateMinLength\" ;\n      sh:jsLibrary dash:DASHJSLibrary ;\n    ] ;\n.\nsh:NodeConstraintComponent\n  sh:message \"Value does not have shape {$node}\" ;\n  sh:targetClass sh:Shape ;\n  sh:validator [\n      rdf:type sh:JSValidator ;\n      sh:jsFunctionName \"validateNode\" ;\n      sh:jsLibrary dash:DASHJSLibrary ;\n    ] ;\n.\nsh:NodeKindConstraintComponent\n  dash:staticConstraint \"true\"^^xsd:boolean ;\n  sh:message \"Value does not have node kind {$nodeKind}\" ;\n  sh:targetClass sh:Shape ;\n  sh:validator dash:hasNodeKind ;\n  sh:validator [\n      rdf:type sh:JSValidator ;\n      sh:jsFunctionName \"validateNodeKind\" ;\n      sh:jsLibrary dash:DASHJSLibrary ;\n    ] ;\n.\nsh:NotConstraintComponent\n  sh:message \"Value does have shape {$not}\" ;\n  sh:targetClass sh:Shape ;\n  sh:validator [\n      rdf:type sh:JSValidator ;\n      sh:jsFunctionName \"validateNot\" ;\n      sh:jsLibrary dash:DASHJSLibrary ;\n    ] ;\n.\nsh:OrConstraintComponent\n  sh:targetClass sh:Shape ;\n  sh:validator [\n      rdf:type sh:JSValidator ;\n      sh:jsFunctionName \"validateOr\" ;\n      sh:jsLibrary dash:DASHJSLibrary ;\n    ] ;\n.\nsh:PatternConstraintComponent\n  dash:staticConstraint \"true\"^^xsd:boolean ;\n  sh:message \"Value does not match pattern \\\"{$pattern}\\\"\" ;\n  sh:targetClass sh:Shape ;\n  sh:validator dash:hasPattern ;\n  sh:validator [\n      rdf:type sh:JSValidator ;\n      sh:jsFunctionName \"validatePattern\" ;\n      sh:jsLibrary dash:DASHJSLibrary ;\n    ] ;\n.\nsh:QualifiedMaxCountConstraintComponent\n  sh:message \"More than {$qualifiedMaxCount} values have shape {$qualifiedValueShape}\" ;\n  sh:propertyValidator [\n      rdf:type sh:JSValidator ;\n      sh:jsFunctionName \"validateQualifiedMaxCountProperty\" ;\n      sh:jsLibrary dash:DASHJSLibrary ;\n    ] ;\n  sh:targetClass sh:PropertyShape ;\n.\nsh:QualifiedMinCountConstraintComponent\n  sh:message \"Less than {$qualifiedMinCount} values have shape {$qualifiedValueShape}\" ;\n  sh:propertyValidator [\n      rdf:type sh:JSValidator ;\n      sh:jsFunctionName \"validateQualifiedMinCountProperty\" ;\n      sh:jsLibrary dash:DASHJSLibrary ;\n    ] ;\n  sh:targetClass sh:PropertyShape ;\n.\nsh:UniqueLangConstraintComponent\n  dash:localConstraint \"true\"^^xsd:boolean ;\n  sh:message \"Language \\\"{?lang}\\\" used more than once\" ;\n  sh:propertyValidator [\n      rdf:type sh:JSValidator ;\n      sh:jsFunctionName \"validateUniqueLangProperty\" ;\n      sh:jsLibrary dash:DASHJSLibrary ;\n    ] ;\n  sh:propertyValidator [\n      rdf:type sh:SPARQLSelectValidator ;\n      sh:prefixes <http://datashapes.org/dash> ;\n      sh:select \"\"\"\n\t\tSELECT DISTINCT $this ?lang\n\t\tWHERE {\n\t\t\t{\n\t\t\t\tFILTER sameTerm($uniqueLang, true) .\n\t\t\t}\n\t\t\t$this $PATH ?value .\n\t\t\tBIND (lang(?value) AS ?lang) .\n\t\t\tFILTER (bound(?lang) && ?lang != \\\"\\\") .\n\t\t\tFILTER EXISTS {\n\t\t\t\t$this $PATH ?otherValue .\n\t\t\t\tFILTER (?otherValue != ?value && ?lang = lang(?otherValue)) .\n\t\t\t}\n\t\t}\n\t\t\"\"\" ;\n    ] ;\n  sh:targetClass sh:PropertyShape ;\n.\nsh:XoneConstraintComponent\n  sh:targetClass sh:Shape ;\n  sh:validator [\n      rdf:type sh:JSValidator ;\n      sh:jsFunctionName \"validateXone\" ;\n      sh:jsLibrary dash:DASHJSLibrary ;\n    ] ;\n.\nsh:node\n  dash:defaultValueType sh:NodeShape ;\n.\nsh:not\n  dash:defaultValueType sh:Shape ;\n.\nsh:order\n  rdfs:range xsd:decimal ;\n.\nsh:parameter\n  dash:defaultValueType sh:Parameter ;\n.\nsh:property\n  dash:defaultValueType sh:PropertyShape ;\n.\nsh:qualifiedValueShape\n  dash:defaultValueType sh:Shape ;\n.\nsh:sparql\n  dash:defaultValueType sh:SPARQLConstraint ;\n.\n","shacl":"##  W3C SOFTWARE AND DOCUMENT NOTICE AND LICENSE\n## https://www.w3.org/Consortium/Legal/2015/copyright-software-and-document\n## --------\n\n# W3C Shapes Constraint Language (SHACL) Vocabulary\n# Version from 2017-07-20\n\n@prefix owl:  <http://www.w3.org/2002/07/owl#> .\n@prefix rdf:  <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .\n@prefix rdfs: <http://www.w3.org/2000/01/rdf-schema#> .\n@prefix xsd:  <http://www.w3.org/2001/XMLSchema#> .\n\n@prefix sh:   <http://www.w3.org/ns/shacl#> .\n\nsh:\n\ta owl:Ontology ;\n\trdfs:label \"W3C Shapes Constraint Language (SHACL) Vocabulary\"@en ;\n\trdfs:comment \"This vocabulary defines terms used in SHACL, the W3C Shapes Constraint Language.\"@en ;\n\tsh:declare [\n\t\tsh:prefix \"sh\" ;\n\t\tsh:namespace \"http://www.w3.org/ns/shacl#\" ;\n\t] ;\n\tsh:suggestedShapesGraph <http://www.w3.org/ns/shacl-shacl#> .\n\n\n# Shapes vocabulary -----------------------------------------------------------\n\nsh:Shape\n\ta rdfs:Class ;\n\trdfs:label \"Shape\"@en ;\n\trdfs:comment \"A shape is a collection of constraints that may be targeted for certain nodes.\"@en ;\n\trdfs:subClassOf rdfs:Resource ;\n\trdfs:isDefinedBy sh: .\n\nsh:NodeShape\n\ta rdfs:Class ;\n\trdfs:label \"Node shape\"@en ;\n\trdfs:comment \"A node shape is a shape that specifies constraint that need to be met with respect to focus nodes.\"@en ;\n\trdfs:subClassOf sh:Shape ;\n\trdfs:isDefinedBy sh: .\n\nsh:PropertyShape\n\ta rdfs:Class ;\n\trdfs:label \"Property shape\"@en ;\n\trdfs:comment \"A property shape is a shape that specifies constraints on the values of a focus node for a given property or path.\"@en ;\n\trdfs:subClassOf sh:Shape ;\n\trdfs:isDefinedBy sh: .\n\nsh:deactivated\n\ta rdf:Property ;\n\trdfs:label \"deactivated\"@en ;\n\trdfs:comment \"If set to true then all nodes conform to this.\"@en ;\n\t# rdfs:domain sh:Shape or sh:SPARQLConstraint\n\trdfs:range xsd:boolean ;\n\trdfs:isDefinedBy sh: .\n\nsh:targetClass \n\ta rdf:Property ;\n\trdfs:label \"target class\"@en ;\n\trdfs:comment \"Links a shape to a class, indicating that all instances of the class must conform to the shape.\"@en ;\n\trdfs:domain sh:Shape ;\n\trdfs:range rdfs:Class ;\n\trdfs:isDefinedBy sh: .\n\nsh:targetNode \n\ta rdf:Property ;\n\trdfs:label \"target node\"@en ;\n\trdfs:comment \"Links a shape to individual nodes, indicating that these nodes must conform to the shape.\"@en ;\n\trdfs:domain sh:Shape ;\n\trdfs:isDefinedBy sh: .\n\nsh:targetObjectsOf\n\ta rdf:Property ;\n\trdfs:label \"target objects of\"@en ;\n\trdfs:comment \"Links a shape to a property, indicating that all all objects of triples that have the given property as their predicate must conform to the shape.\"@en ;\n\trdfs:domain sh:Shape ;\n\trdfs:range rdf:Property ;\n\trdfs:isDefinedBy sh: .\n\nsh:targetSubjectsOf\n\ta rdf:Property ;\n\trdfs:label \"target subjects of\"@en ;\n\trdfs:comment \"Links a shape to a property, indicating that all subjects of triples that have the given property as their predicate must conform to the shape.\"@en ;\n\trdfs:domain sh:Shape ;\n\trdfs:range rdf:Property ;\n\trdfs:isDefinedBy sh: .\n\nsh:message\n\ta rdf:Property ;\n\t# domain: sh:Shape or sh:SPARQLConstraint or sh:SPARQLSelectValidator or sh:SPARQLAskValidator\n\t# range: xsd:string or rdf:langString\n\trdfs:label \"message\"@en ;\n\trdfs:comment \"A human-readable message (possibly with placeholders for variables) explaining the cause of the result.\"@en ;\n\trdfs:isDefinedBy sh: .\n\nsh:severity\n\ta rdf:Property ;\n\trdfs:label \"severity\"@en ;\n\trdfs:comment \"Defines the severity that validation results produced by a shape must have. Defaults to sh:Violation.\"@en ;\n\trdfs:domain sh:Shape ;\n\trdfs:range sh:Severity ;\n\trdfs:isDefinedBy sh: .\n\n\n# Node kind vocabulary --------------------------------------------------------\n\nsh:NodeKind\n\ta rdfs:Class ;\n\trdfs:label \"Node kind\"@en ;\n\trdfs:comment \"The class of all node kinds, including sh:BlankNode, sh:IRI, sh:Literal or the combinations of these: sh:BlankNodeOrIRI, sh:BlankNodeOrLiteral, sh:IRIOrLiteral.\"@en ;\n\trdfs:subClassOf rdfs:Resource ;\n\trdfs:isDefinedBy sh: .\n\nsh:BlankNode\n\ta sh:NodeKind ;\n\trdfs:label \"Blank node\"@en ;\n\trdfs:comment \"The node kind of all blank nodes.\"@en ;\n\trdfs:isDefinedBy sh: .\n\nsh:BlankNodeOrIRI\n\ta sh:NodeKind ;\n\trdfs:label \"Blank node or IRI\"@en ;\n\trdfs:comment \"The node kind of all blank nodes or IRIs.\"@en ;\n\trdfs:isDefinedBy sh: .\n\nsh:BlankNodeOrLiteral\n\ta sh:NodeKind ;\n\trdfs:label \"Blank node or literal\"@en ;\n\trdfs:comment \"The node kind of all blank nodes or literals.\"@en ;\n\trdfs:isDefinedBy sh: .\n\nsh:IRI\n\ta sh:NodeKind ;\n\trdfs:label \"IRI\"@en ;\n\trdfs:comment \"The node kind of all IRIs.\"@en ;\n\trdfs:isDefinedBy sh: .\n\nsh:IRIOrLiteral\n\ta sh:NodeKind ;\n\trdfs:label \"IRI or literal\"@en ;\n\trdfs:comment \"The node kind of all IRIs or literals.\"@en ;\n\trdfs:isDefinedBy sh: .\n\nsh:Literal\n\ta sh:NodeKind ;\n\trdfs:label \"Literal\"@en ;\n\trdfs:comment \"The node kind of all literals.\"@en ;\n\trdfs:isDefinedBy sh: .\n\n\n# Results vocabulary ----------------------------------------------------------\n\nsh:ValidationReport\n\ta rdfs:Class ;\n\trdfs:label \"Validation report\"@en ;\n\trdfs:comment \"The class of SHACL validation reports.\"@en ;\n\trdfs:subClassOf rdfs:Resource ;\n\trdfs:isDefinedBy sh: .\n\nsh:conforms\n\ta rdf:Property ;\n\trdfs:label \"conforms\"@en ;\n\trdfs:comment \"True if the validation did not produce any validation results, and false otherwise.\"@en ;\n\trdfs:domain sh:ValidationReport ;\n\trdfs:range xsd:boolean ;\n\trdfs:isDefinedBy sh: .\n\nsh:result\n\ta rdf:Property ;\n\trdfs:label \"result\"@en ;\n\trdfs:comment \"The validation results contained in a validation report.\"@en ;\n\trdfs:domain sh:ValidationReport ;\n\trdfs:range sh:ValidationResult ;\n\trdfs:isDefinedBy sh: .\n\nsh:shapesGraphWellFormed\n\ta rdf:Property ;\n\trdfs:label \"shapes graph well-formed\"@en ;\n\trdfs:comment \"If true then the validation engine was certain that the shapes graph has passed all SHACL syntax requirements during the validation process.\"@en ;\n\trdfs:domain sh:ValidationReport ;\n\trdfs:range xsd:boolean ;\n\trdfs:isDefinedBy sh: .\n\nsh:AbstractResult\n\ta rdfs:Class ;\n\trdfs:label \"Abstract result\"@en ;\n\trdfs:comment \"The base class of validation results, typically not instantiated directly.\"@en ;\n\trdfs:subClassOf rdfs:Resource ;\n\trdfs:isDefinedBy sh: .\n\nsh:ValidationResult\n\ta rdfs:Class ;\n\trdfs:label \"Validation result\"@en ;\n\trdfs:comment \"The class of validation results.\"@en ;\n\trdfs:subClassOf sh:AbstractResult ;\n\trdfs:isDefinedBy sh: .\n\nsh:Severity\n\ta rdfs:Class ;\n\trdfs:label \"Severity\"@en ;\n\trdfs:comment \"The class of validation result severity levels, including violation and warning levels.\"@en ;\n\trdfs:subClassOf rdfs:Resource ;\n\trdfs:isDefinedBy sh: .\n\nsh:Info\n\ta sh:Severity ;\n\trdfs:label \"Info\"@en ;\n\trdfs:comment \"The severity for an informational validation result.\"@en ;\n\trdfs:isDefinedBy sh: .\n\nsh:Violation\n\ta sh:Severity ;\n\trdfs:label \"Violation\"@en ;\n\trdfs:comment \"The severity for a violation validation result.\"@en ;\n\trdfs:isDefinedBy sh: .\n\nsh:Warning\n\ta sh:Severity ;\n\trdfs:label \"Warning\"@en ;\n\trdfs:comment \"The severity for a warning validation result.\"@en ;\n\trdfs:isDefinedBy sh: .\n\nsh:detail\n\ta rdf:Property ;\n\trdfs:label \"detail\"@en ;\n\trdfs:comment \"Links a result with other results that provide more details, for example to describe violations against nested shapes.\"@en ;\n\trdfs:domain sh:AbstractResult ;\n\trdfs:range sh:AbstractResult ;\n\trdfs:isDefinedBy sh: .\n\nsh:focusNode\n\ta rdf:Property ;\n\trdfs:label \"focus node\"@en ;\n\trdfs:comment \"The focus node that was validated when the result was produced.\"@en ;\n\trdfs:domain sh:AbstractResult ;\n\trdfs:isDefinedBy sh: .\n\nsh:resultMessage\n\ta rdf:Property ;\n\trdfs:label \"result message\"@en ;\n\trdfs:comment \"Human-readable messages explaining the cause of the result.\"@en ;\n\trdfs:domain sh:AbstractResult ;\n\t# range: xsd:string or rdf:langString\n\trdfs:isDefinedBy sh: .\n\nsh:resultPath\n\ta rdf:Property ;\n\trdfs:label \"result path\"@en ;\n\trdfs:comment \"The path of a validation result, based on the path of the validated property shape.\"@en ;\n\trdfs:domain sh:AbstractResult ;\n\trdfs:range rdfs:Resource ;\n\trdfs:isDefinedBy sh: .\n\nsh:resultSeverity\n\ta rdf:Property ;\n\trdfs:label \"result severity\"@en ;\n\trdfs:comment \"The severity of the result, e.g. warning.\"@en ;\n\trdfs:domain sh:AbstractResult ;\n\trdfs:range sh:Severity ;\n\trdfs:isDefinedBy sh: .\n\nsh:sourceConstraint\n\ta rdf:Property ;\n\trdfs:label \"source constraint\"@en ;\n\trdfs:comment \"The constraint that was validated when the result was produced.\"@en ;\n\trdfs:domain sh:AbstractResult ;\n\trdfs:isDefinedBy sh: .\n\nsh:sourceShape\n\ta rdf:Property ;\n\trdfs:label \"source shape\"@en ;\n\trdfs:comment \"The shape that is was validated when the result was produced.\"@en ;\n\trdfs:domain sh:AbstractResult ;\n\trdfs:range sh:Shape ;\n\trdfs:isDefinedBy sh: .\n\nsh:sourceConstraintComponent\n\ta rdf:Property ;\n\trdfs:label \"source constraint component\"@en ;\n\trdfs:comment \"The constraint component that is the source of the result.\"@en ;\n\trdfs:domain sh:AbstractResult ;\n\trdfs:range sh:ConstraintComponent ;\n\trdfs:isDefinedBy sh: .\n\nsh:value\n\ta rdf:Property ;\n\trdfs:label \"value\"@en ;\n\trdfs:comment \"An RDF node that has caused the result.\"@en ;\n\trdfs:domain sh:AbstractResult ;\n\trdfs:isDefinedBy sh: .\n\n\t\n# Graph properties ------------------------------------------------------------\n\nsh:shapesGraph\n\ta rdf:Property ;\n\trdfs:label \"shapes graph\"@en ;\n\trdfs:comment \"Shapes graphs that should be used when validating this data graph.\"@en ;\n\trdfs:domain owl:Ontology ;\n\trdfs:range owl:Ontology ;\n\trdfs:isDefinedBy sh: .\n\nsh:suggestedShapesGraph\n\ta rdf:Property ;\n\trdfs:label \"suggested shapes graph\"@en ;\n\trdfs:comment \"Suggested shapes graphs for this ontology. The values of this property may be used in the absence of specific sh:shapesGraph statements.\"@en ;\n\trdfs:domain owl:Ontology ;\n\trdfs:range owl:Ontology ;\n\trdfs:isDefinedBy sh: .\n\nsh:entailment\n\ta rdf:Property ;\n\trdfs:label \"entailment\"@en ;\n\trdfs:comment \"An entailment regime that indicates what kind of inferencing is required by a shapes graph.\"@en ;\n\trdfs:domain owl:Ontology ;\n\trdfs:range rdfs:Resource ;\n\trdfs:isDefinedBy sh: .\n\n\n# Path vocabulary -------------------------------------------------------------\n\nsh:path\n\ta rdf:Property ;\n\trdfs:label \"path\"@en ;\n\trdfs:comment \"Specifies the property path of a property shape.\"@en ;\n\trdfs:domain sh:PropertyShape ;\n\trdfs:range rdfs:Resource ;\n\trdfs:isDefinedBy sh: .\n\nsh:inversePath\n\ta rdf:Property ;\n\trdfs:label \"inverse path\"@en ;\n\trdfs:comment \"The (single) value of this property represents an inverse path (object to subject).\"@en ;\n\trdfs:range rdfs:Resource ;\n\trdfs:isDefinedBy sh: .\n\nsh:alternativePath\n\ta rdf:Property ;\n\trdfs:label \"alternative path\"@en ;\n\trdfs:comment \"The (single) value of this property must be a list of path elements, representing the elements of alternative paths.\"@en ;\n\trdfs:range rdf:List ;\n\trdfs:isDefinedBy sh: .\n\nsh:zeroOrMorePath\n\ta rdf:Property ;\n\trdfs:label \"zero or more path\"@en ;\n\trdfs:comment \"The (single) value of this property represents a path that is matched zero or more times.\"@en ;\n\trdfs:range rdfs:Resource ;\n\trdfs:isDefinedBy sh: .\n\nsh:oneOrMorePath\n\ta rdf:Property ;\n\trdfs:label \"one or more path\"@en ;\n\trdfs:comment \"The (single) value of this property represents a path that is matched one or more times.\"@en ;\n\trdfs:range rdfs:Resource ;\n\trdfs:isDefinedBy sh: .\n\nsh:zeroOrOnePath\n\ta rdf:Property ;\n\trdfs:label \"zero or one path\"@en ;\n\trdfs:comment \"The (single) value of this property represents a path that is matched zero or one times.\"@en ;\n\trdfs:range rdfs:Resource ;\n\trdfs:isDefinedBy sh: .\n\n\n# Parameters metamodel --------------------------------------------------------\n\nsh:Parameterizable\n\ta rdfs:Class ;\n\trdfs:label \"Parameterizable\"@en ;\n\trdfs:comment \"Superclass of components that can take parameters, especially functions and constraint components.\"@en ;\n\trdfs:subClassOf rdfs:Resource ;\n\trdfs:isDefinedBy sh: .\n\nsh:parameter\n\ta rdf:Property ;\n\trdfs:label \"parameter\"@en ;\n\trdfs:comment \"The parameters of a function or constraint component.\"@en ;\n\trdfs:domain sh:Parameterizable ;\n\trdfs:range sh:Parameter ;\n\trdfs:isDefinedBy sh: .\n\nsh:labelTemplate\n\ta rdf:Property ;\n\trdfs:label \"label template\"@en ;\n\trdfs:comment \"Outlines how human-readable labels of instances of the associated Parameterizable shall be produced. The values can contain {?paramName} as placeholders for the actual values of the given parameter.\"@en ;\n\trdfs:domain sh:Parameterizable ;\n\t# range: xsd:string or rdf:langString\n\trdfs:isDefinedBy sh: .\n\nsh:Parameter\n\ta rdfs:Class ;\n\trdfs:label \"Parameter\"@en ;\n\trdfs:comment \"The class of parameter declarations, consisting of a path predicate and (possibly) information about allowed value type, cardinality and other characteristics.\"@en ;\n\trdfs:subClassOf sh:PropertyShape ;\n\trdfs:isDefinedBy sh: .\n\nsh:optional\n\ta rdf:Property ;\n\trdfs:label \"optional\"@en ;\n\trdfs:comment \"Indicates whether a parameter is optional.\"@en ;\n\trdfs:domain sh:Parameter ;\n\trdfs:range xsd:boolean ;\n\trdfs:isDefinedBy sh: .\n\n\n# Constraint components metamodel ---------------------------------------------\n\nsh:ConstraintComponent\n\ta rdfs:Class ;\n\trdfs:label \"Constraint component\"@en ;\n\trdfs:comment \"The class of constraint components.\"@en ;\n\trdfs:subClassOf sh:Parameterizable ;\n\trdfs:isDefinedBy sh: .\n\nsh:validator\n\ta rdf:Property ;\n\trdfs:label \"validator\"@en ;\n\trdfs:comment \"The validator(s) used to evaluate constraints of either node or property shapes.\"@en ;\n\trdfs:domain sh:ConstraintComponent ;\n\trdfs:range sh:Validator ;\n\trdfs:isDefinedBy sh: .\n\nsh:nodeValidator\n\ta rdf:Property ;\n\trdfs:label \"shape validator\"@en ;\n\trdfs:comment \"The validator(s) used to evaluate a constraint in the context of a node shape.\"@en ;\n\trdfs:domain sh:ConstraintComponent ;\n\trdfs:range sh:Validator ;\n\trdfs:isDefinedBy sh: .\n\nsh:propertyValidator\n\ta rdf:Property ;\n\trdfs:label \"property validator\"@en ;\n\trdfs:comment \"The validator(s) used to evaluate a constraint in the context of a property shape.\"@en ;\n\trdfs:domain sh:ConstraintComponent ;\n\trdfs:range sh:Validator ;\n\trdfs:isDefinedBy sh: .\n\nsh:Validator\n\ta rdfs:Class ;\n\trdfs:label \"Validator\"@en ;\n\trdfs:comment \"The class of validators, which provide instructions on how to process a constraint definition. This class serves as base class for the SPARQL-based validators and other possible implementations.\"@en ;\n\trdfs:subClassOf rdfs:Resource ;\n\trdfs:isDefinedBy sh: .\n\nsh:SPARQLAskValidator\n\ta rdfs:Class ;\n\trdfs:label \"SPARQL ASK validator\"@en ;\n\trdfs:comment \"The class of validators based on SPARQL ASK queries. The queries are evaluated for each value node and are supposed to return true if the given node conforms.\"@en ;\n\trdfs:subClassOf sh:Validator ;\n\trdfs:subClassOf sh:SPARQLAskExecutable ;\n\trdfs:isDefinedBy sh: .\n\nsh:SPARQLSelectValidator\n\ta rdfs:Class ;\n\trdfs:label \"SPARQL SELECT validator\"@en ;\n\trdfs:comment \"The class of validators based on SPARQL SELECT queries. The queries are evaluated for each focus node and are supposed to produce bindings for all focus nodes that do not conform.\"@en ;\n\trdfs:subClassOf sh:Validator ;\n\trdfs:subClassOf sh:SPARQLSelectExecutable ;\n\trdfs:isDefinedBy sh: .\n\n\n# Library of Core Constraint Components and their properties ------------------\n\nsh:AndConstraintComponent\n\ta sh:ConstraintComponent ;\n\trdfs:label \"And constraint component\"@en ;\n\trdfs:comment \"A constraint component that can be used to test whether a value node conforms to all members of a provided list of shapes.\"@en ;\n\tsh:parameter sh:AndConstraintComponent-and ;\n\trdfs:isDefinedBy sh: .\n\nsh:AndConstraintComponent-and\n\ta sh:Parameter ;\n\tsh:path sh:and ;\n\trdfs:isDefinedBy sh: .\n\nsh:and\n\ta rdf:Property ;\n\trdfs:label \"and\"@en ;\n\trdfs:comment \"RDF list of shapes to validate the value nodes against.\"@en ;\n\trdfs:range rdf:List ;\n\trdfs:isDefinedBy sh: .\n\n\nsh:ClassConstraintComponent \n\ta sh:ConstraintComponent ;\n\trdfs:label \"Class constraint component\"@en ;\n\trdfs:comment \"A constraint component that can be used to verify that each value node is an instance of a given type.\"@en ;\n\tsh:parameter sh:ClassConstraintComponent-class ;\n\trdfs:isDefinedBy sh: .\n\nsh:ClassConstraintComponent-class\n\ta sh:Parameter ;\n\tsh:path sh:class ;\n\tsh:nodeKind sh:IRI ;\n\trdfs:isDefinedBy sh: .\n\nsh:class\n\ta rdf:Property ;\n\trdfs:label \"class\"@en ;\n\trdfs:comment \"The type that all value nodes must have.\"@en ;\n\trdfs:range rdfs:Class ;\n\trdfs:isDefinedBy sh: .\n\n\nsh:ClosedConstraintComponent\n\ta sh:ConstraintComponent ;\n\trdfs:label \"Closed constraint component\"@en ;\n\trdfs:comment \"A constraint component that can be used to indicate that focus nodes must only have values for those properties that have been explicitly enumerated via sh:property/sh:path.\"@en ;\n\tsh:parameter sh:ClosedConstraintComponent-closed ;\n\tsh:parameter sh:ClosedConstraintComponent-ignoredProperties ;\n\trdfs:isDefinedBy sh: .\n\nsh:ClosedConstraintComponent-closed\n\ta sh:Parameter ; \n\tsh:path sh:closed ;\n\tsh:datatype xsd:boolean ;\n\trdfs:isDefinedBy sh: .\n\nsh:ClosedConstraintComponent-ignoredProperties\n\ta sh:Parameter ;\n\tsh:path sh:ignoredProperties ;\n\tsh:optional true ;\n\trdfs:isDefinedBy sh: .\n\nsh:closed\n\ta rdf:Property ;\n\trdfs:label \"closed\"@en ;\n\trdfs:comment \"If set to true then the shape is closed.\"@en ;\n\trdfs:range xsd:boolean ;\n\trdfs:isDefinedBy sh: .\n\nsh:ignoredProperties\n\ta rdf:Property ;\n\trdfs:label \"ignored properties\"@en ;\n\trdfs:comment \"An optional RDF list of properties that are also permitted in addition to those explicitly enumerated via sh:property/sh:path.\"@en ;\n\trdfs:range rdf:List ;    # members: rdf:Property\n\trdfs:isDefinedBy sh: .\n\n\nsh:DatatypeConstraintComponent\n\ta sh:ConstraintComponent ;\n\trdfs:label \"Datatype constraint component\"@en ;\n\trdfs:comment \"A constraint component that can be used to restrict the datatype of all value nodes.\"@en ;\n\tsh:parameter sh:DatatypeConstraintComponent-datatype ;\n\trdfs:isDefinedBy sh: .\n\nsh:DatatypeConstraintComponent-datatype\n\ta sh:Parameter ;\n\tsh:path sh:datatype ;\n\tsh:nodeKind sh:IRI ;\n\tsh:maxCount 1 ;\n\trdfs:isDefinedBy sh: .\n\nsh:datatype\n\ta rdf:Property ;\n\trdfs:label \"datatype\"@en ;\n\trdfs:comment \"Specifies an RDF datatype that all value nodes must have.\"@en ;\n\trdfs:range rdfs:Datatype ;\n\trdfs:isDefinedBy sh: .\n\n\nsh:DisjointConstraintComponent\n\ta sh:ConstraintComponent ;\n\trdfs:label \"Disjoint constraint component\"@en ;\n\trdfs:comment \"A constraint component that can be used to verify that the set of value nodes is disjoint with the the set of nodes that have the focus node as subject and the value of a given property as predicate.\"@en ;\n\tsh:parameter sh:DisjointConstraintComponent-disjoint ;\n\trdfs:isDefinedBy sh: .\n\nsh:DisjointConstraintComponent-disjoint\n\ta sh:Parameter ;\n\tsh:path sh:disjoint ;\n\tsh:nodeKind sh:IRI ;\n\trdfs:isDefinedBy sh: .\n\nsh:disjoint\n\ta rdf:Property ;\n\trdfs:label \"disjoint\"@en ;\n\trdfs:comment \"Specifies a property where the set of values must be disjoint with the value nodes.\"@en ;\n\trdfs:range rdf:Property ;\n\trdfs:isDefinedBy sh: .\n\n\nsh:EqualsConstraintComponent\n\ta sh:ConstraintComponent ;\n\trdfs:label \"Equals constraint component\"@en ;\n\trdfs:comment \"A constraint component that can be used to verify that the set of value nodes is equal to the set of nodes that have the focus node as subject and the value of a given property as predicate.\"@en ;\n\tsh:parameter sh:EqualsConstraintComponent-equals ;\n\trdfs:isDefinedBy sh: .\n\nsh:EqualsConstraintComponent-equals\n\ta sh:Parameter ;\n\tsh:path sh:equals ;\n\tsh:nodeKind sh:IRI ;\n\trdfs:isDefinedBy sh: .\n\nsh:equals\n\ta rdf:Property ;\n\trdfs:label \"equals\"@en ;\n\trdfs:comment \"Specifies a property that must have the same values as the value nodes.\"@en ;\n\trdfs:range rdf:Property ;\n\trdfs:isDefinedBy sh: .\n\n\nsh:HasValueConstraintComponent\n\ta sh:ConstraintComponent ;\n\trdfs:label \"Has-value constraint component\"@en ;\n\trdfs:comment \"A constraint component that can be used to verify that one of the value nodes is a given RDF node.\"@en ;\n\tsh:parameter sh:HasValueConstraintComponent-hasValue ;\n\trdfs:isDefinedBy sh: .\n\nsh:HasValueConstraintComponent-hasValue\n\ta sh:Parameter ;\n\tsh:path sh:hasValue ;\n\trdfs:isDefinedBy sh: .\n\nsh:hasValue\n\ta rdf:Property ;\n\trdfs:label \"has value\"@en ;\n\trdfs:comment \"Specifies a value that must be among the value nodes.\"@en ;\n\trdfs:isDefinedBy sh: .\n\n\nsh:InConstraintComponent\n\ta sh:ConstraintComponent ;\n\trdfs:label \"In constraint component\"@en ;\n\trdfs:comment \"A constraint component that can be used to exclusively enumerate the permitted value nodes.\"@en ;\n\tsh:parameter sh:InConstraintComponent-in ;\n\trdfs:isDefinedBy sh: .\n\nsh:InConstraintComponent-in\n\ta sh:Parameter ;\n\tsh:path sh:in ;\n\tsh:maxCount 1 ;\n\trdfs:isDefinedBy sh: .\n\nsh:in\n\ta rdf:Property ;\n\trdfs:label \"in\"@en ;\n\trdfs:comment \"Specifies a list of allowed values so that each value node must be among the members of the given list.\"@en ;\n\trdfs:range rdf:List ;\n\trdfs:isDefinedBy sh: .\n\n\nsh:LanguageInConstraintComponent\n\ta sh:ConstraintComponent ;\n\trdfs:label \"Language-in constraint component\"@en ;\n\trdfs:comment \"A constraint component that can be used to enumerate language tags that all value nodes must have.\"@en ;\n\tsh:parameter sh:LanguageInConstraintComponent-languageIn ;\n\trdfs:isDefinedBy sh: .\n\nsh:LanguageInConstraintComponent-languageIn\n\ta sh:Parameter ;\n\tsh:path sh:languageIn ;\n\tsh:maxCount 1 ;\n\trdfs:isDefinedBy sh: .\n\nsh:languageIn\n\ta rdf:Property ;\n\trdfs:label \"language in\"@en ;\n\trdfs:comment \"Specifies a list of language tags that all value nodes must have.\"@en ;\n\trdfs:range rdf:List ;   # members: xsd:string\n\trdfs:isDefinedBy sh: .\n\n\nsh:LessThanConstraintComponent\n\ta sh:ConstraintComponent ;\n\trdfs:label \"Less-than constraint component\"@en ;\n\trdfs:comment \"A constraint component that can be used to verify that each value node is smaller than all the nodes that have the focus node as subject and the value of a given property as predicate.\"@en ;\n\tsh:parameter sh:LessThanConstraintComponent-lessThan ;\n\trdfs:isDefinedBy sh: .\n\nsh:LessThanConstraintComponent-lessThan\n\ta sh:Parameter ;\n\tsh:path sh:lessThan ;\n\tsh:nodeKind sh:IRI ;\n\trdfs:isDefinedBy sh: .\n\nsh:lessThan\n\ta rdf:Property ;\n\trdfs:label \"less than\"@en ;\n\trdfs:comment \"Specifies a property that must have smaller values than the value nodes.\"@en ;\n\trdfs:range rdf:Property ;\n\trdfs:isDefinedBy sh: .\n\n\nsh:LessThanOrEqualsConstraintComponent\n\ta sh:ConstraintComponent ;\n\trdfs:label \"less-than-or-equals constraint component\"@en ;\n\trdfs:comment \"A constraint component that can be used to verify that every value node is smaller than all the nodes that have the focus node as subject and the value of a given property as predicate.\"@en ;\n\tsh:parameter sh:LessThanOrEqualsConstraintComponent-lessThanOrEquals ;\n\trdfs:isDefinedBy sh: .\n\nsh:LessThanOrEqualsConstraintComponent-lessThanOrEquals\n\ta sh:Parameter ;\n\tsh:path sh:lessThanOrEquals ;\n\tsh:nodeKind sh:IRI ;\n\trdfs:isDefinedBy sh: .\n\nsh:lessThanOrEquals\n\ta rdf:Property ;\n\trdfs:label \"less than or equals\"@en ;\n\trdfs:comment \"Specifies a property that must have smaller or equal values than the value nodes.\"@en ;\n\trdfs:range rdf:Property ;\n\trdfs:isDefinedBy sh: .\n\n\nsh:MaxCountConstraintComponent\n\ta sh:ConstraintComponent ;\n\trdfs:label \"Max-count constraint component\"@en ;\n\trdfs:comment \"A constraint component that can be used to restrict the maximum number of value nodes.\"@en ;\n\tsh:parameter sh:MaxCountConstraintComponent-maxCount ;\n\trdfs:isDefinedBy sh: .\n\nsh:MaxCountConstraintComponent-maxCount\n\ta sh:Parameter ;\n\tsh:path sh:maxCount ;\n\tsh:datatype xsd:integer ;\n\tsh:maxCount 1 ;\n\trdfs:isDefinedBy sh: .\n\nsh:maxCount\n\ta rdf:Property ;\n\trdfs:label \"max count\"@en ;\n\trdfs:comment \"Specifies the maximum number of values in the set of value nodes.\"@en ;\n\trdfs:range xsd:integer ;\n\trdfs:isDefinedBy sh: .\n\n\nsh:MaxExclusiveConstraintComponent\n\ta sh:ConstraintComponent ;\n\trdfs:label \"Max-exclusive constraint component\"@en ;\n\trdfs:comment \"A constraint component that can be used to restrict the range of value nodes with a maximum exclusive value.\"@en ;\n\tsh:parameter sh:MaxExclusiveConstraintComponent-maxExclusive ;\n\trdfs:isDefinedBy sh: .\n\nsh:MaxExclusiveConstraintComponent-maxExclusive\n\ta sh:Parameter ;\n\tsh:path sh:maxExclusive ;\n\tsh:maxCount 1 ;\n\tsh:nodeKind sh:Literal ;\n\trdfs:isDefinedBy sh: .\n\nsh:maxExclusive\n\ta rdf:Property ;\n\trdfs:label \"max exclusive\"@en ;\n\trdfs:comment \"Specifies the maximum exclusive value of each value node.\"@en ;\n\trdfs:isDefinedBy sh: .\n\n\nsh:MaxInclusiveConstraintComponent\n\ta sh:ConstraintComponent ;\n\trdfs:label \"Max-inclusive constraint component\"@en ;\n\trdfs:comment \"A constraint component that can be used to restrict the range of value nodes with a maximum inclusive value.\"@en ;\n\tsh:parameter sh:MaxInclusiveConstraintComponent-maxInclusive ;\n\trdfs:isDefinedBy sh: .\n\nsh:MaxInclusiveConstraintComponent-maxInclusive\n\ta sh:Parameter ;\n\tsh:path sh:maxInclusive ;\n\tsh:maxCount 1 ;\n\tsh:nodeKind sh:Literal ;\n\trdfs:isDefinedBy sh: .\n\nsh:maxInclusive\n\ta rdf:Property ;\n\trdfs:label \"max inclusive\"@en ;\n\trdfs:comment \"Specifies the maximum inclusive value of each value node.\"@en ;\n\trdfs:isDefinedBy sh: .\n\n\nsh:MaxLengthConstraintComponent\n\ta sh:ConstraintComponent ;\n\trdfs:label \"Max-length constraint component\"@en ;\n\trdfs:comment \"A constraint component that can be used to restrict the maximum string length of value nodes.\"@en ;\n\tsh:parameter sh:MaxLengthConstraintComponent-maxLength ;\n\trdfs:isDefinedBy sh: .\n\nsh:MaxLengthConstraintComponent-maxLength\n\ta sh:Parameter ;\n\tsh:path sh:maxLength ;\n\tsh:datatype xsd:integer ;\n\tsh:maxCount 1 ;\n\trdfs:isDefinedBy sh: .\n\nsh:maxLength\n\ta rdf:Property ;\n\trdfs:label \"max length\"@en ;\n\trdfs:comment \"Specifies the maximum string length of each value node.\"@en ;\n\trdfs:range xsd:integer ;\n\trdfs:isDefinedBy sh: .\n\n\nsh:MinCountConstraintComponent\n\ta sh:ConstraintComponent ;\n\trdfs:label \"Min-count constraint component\"@en ;\n\trdfs:comment \"A constraint component that can be used to restrict the minimum number of value nodes.\"@en ;\n\tsh:parameter sh:MinCountConstraintComponent-minCount ;\n\trdfs:isDefinedBy sh: .\n\nsh:MinCountConstraintComponent-minCount\n\ta sh:Parameter ;\n\tsh:path sh:minCount ;\n\tsh:datatype xsd:integer ;\n\tsh:maxCount 1 ;\n\trdfs:isDefinedBy sh: .\n\nsh:minCount\n\ta rdf:Property ;\n\trdfs:label \"min count\"@en ;\n\trdfs:comment \"Specifies the minimum number of values in the set of value nodes.\"@en ;\n\trdfs:range xsd:integer ;\n\trdfs:isDefinedBy sh: .\n\n\nsh:MinExclusiveConstraintComponent\n\ta sh:ConstraintComponent ;\n\trdfs:label \"Min-exclusive constraint component\"@en ;\n\trdfs:comment \"A constraint component that can be used to restrict the range of value nodes with a minimum exclusive value.\"@en ;\n\tsh:parameter sh:MinExclusiveConstraintComponent-minExclusive ;\n\trdfs:isDefinedBy sh: .\n\nsh:MinExclusiveConstraintComponent-minExclusive\n\ta sh:Parameter ;\n\tsh:path sh:minExclusive ;\n\tsh:maxCount 1 ;\n\tsh:nodeKind sh:Literal ;\n\trdfs:isDefinedBy sh: .\n\nsh:minExclusive\n\ta rdf:Property ;\n\trdfs:label \"min exclusive\"@en ;\n\trdfs:comment \"Specifies the minimum exclusive value of each value node.\"@en ;\n\trdfs:isDefinedBy sh: .\n\n\nsh:MinInclusiveConstraintComponent\n\ta sh:ConstraintComponent ;\n\trdfs:label \"Min-inclusive constraint component\"@en ;\n\trdfs:comment \"A constraint component that can be used to restrict the range of value nodes with a minimum inclusive value.\"@en ;\n\tsh:parameter sh:MinInclusiveConstraintComponent-minInclusive ;\n\trdfs:isDefinedBy sh: .\n\nsh:MinInclusiveConstraintComponent-minInclusive\n\ta sh:Parameter ;\n\tsh:path sh:minInclusive ;\n\tsh:maxCount 1 ;\n\tsh:nodeKind sh:Literal ;\n\trdfs:isDefinedBy sh: .\n\nsh:minInclusive\n\ta rdf:Property ;\n\trdfs:label \"min inclusive\"@en ;\n\trdfs:comment \"Specifies the minimum inclusive value of each value node.\"@en ;\n\trdfs:isDefinedBy sh: .\n\n\nsh:MinLengthConstraintComponent\n\ta sh:ConstraintComponent ;\n\trdfs:label \"Min-length constraint component\"@en ;\n\trdfs:comment \"A constraint component that can be used to restrict the minimum string length of value nodes.\"@en ;\n\tsh:parameter sh:MinLengthConstraintComponent-minLength ;\n\trdfs:isDefinedBy sh: .\n\nsh:MinLengthConstraintComponent-minLength\n\ta sh:Parameter ;\n\tsh:path sh:minLength ;\n\tsh:datatype xsd:integer ;\n\tsh:maxCount 1 ;\n\trdfs:isDefinedBy sh: .\n\nsh:minLength\n\ta rdf:Property ;\n\trdfs:label \"min length\"@en ;\n\trdfs:comment \"Specifies the minimum string length of each value node.\"@en ;\n\trdfs:range xsd:integer ;\n\trdfs:isDefinedBy sh: .\n\n\nsh:NodeConstraintComponent\n\ta sh:ConstraintComponent ;\n\trdfs:label \"Node constraint component\"@en ;\n\trdfs:comment \"A constraint component that can be used to verify that all value nodes conform to the given node shape.\"@en ;\n\tsh:parameter sh:NodeConstraintComponent-node ;\n\trdfs:isDefinedBy sh: .\n\nsh:NodeConstraintComponent-node\n\ta sh:Parameter ;\n\tsh:path sh:node ;\n\trdfs:isDefinedBy sh: .\n\nsh:node\n\ta rdf:Property ;\n\trdfs:label \"node\"@en ;\n\trdfs:comment \"Specifies the node shape that all value nodes must conform to.\"@en ;\n\trdfs:range sh:NodeShape ;\n\trdfs:isDefinedBy sh: .\n\n\nsh:NodeKindConstraintComponent\n\ta sh:ConstraintComponent ;\n\trdfs:label \"Node-kind constraint component\"@en ;\n\trdfs:comment \"A constraint component that can be used to restrict the RDF node kind of each value node.\"@en ;\n\tsh:parameter sh:NodeKindConstraintComponent-nodeKind ;\n\trdfs:isDefinedBy sh: .\n\nsh:NodeKindConstraintComponent-nodeKind\n\ta sh:Parameter ;\n\tsh:path sh:nodeKind ;\n\tsh:in ( sh:BlankNode sh:IRI sh:Literal sh:BlankNodeOrIRI sh:BlankNodeOrLiteral sh:IRIOrLiteral ) ;\n\tsh:maxCount 1 ;\n\trdfs:isDefinedBy sh: .\n\nsh:nodeKind\n\ta rdf:Property ;\n\trdfs:label \"node kind\"@en ;\n\trdfs:comment \"Specifies the node kind (e.g. IRI or literal) each value node.\"@en ;\n\trdfs:range sh:NodeKind ;\n\trdfs:isDefinedBy sh: .\n\n\nsh:NotConstraintComponent\n\ta sh:ConstraintComponent ;\n\trdfs:label \"Not constraint component\"@en ;\n\trdfs:comment \"A constraint component that can be used to verify that value nodes do not conform to a given shape.\"@en ;\n\tsh:parameter sh:NotConstraintComponent-not ;\n\trdfs:isDefinedBy sh: .\n\nsh:NotConstraintComponent-not\n\ta sh:Parameter ;\n\tsh:path sh:not ;\n\trdfs:isDefinedBy sh: .\n\nsh:not\n\ta rdf:Property ;\n\trdfs:label \"not\"@en ;\n\trdfs:comment \"Specifies a shape that the value nodes must not conform to.\"@en ;\n\trdfs:range sh:Shape ;\n\trdfs:isDefinedBy sh: .\n\n\nsh:OrConstraintComponent\n\ta sh:ConstraintComponent ;\n\trdfs:label \"Or constraint component\"@en ;\n\trdfs:comment \"A constraint component that can be used to restrict the value nodes so that they conform to at least one out of several provided shapes.\"@en ;\n\tsh:parameter sh:OrConstraintComponent-or ;\n\trdfs:isDefinedBy sh: .\n\nsh:OrConstraintComponent-or\n\ta sh:Parameter ;\n\tsh:path sh:or ;\n\trdfs:isDefinedBy sh: .\n\nsh:or\n\ta rdf:Property ;\n\trdfs:label \"or\"@en ;\n\trdfs:comment \"Specifies a list of shapes so that the value nodes must conform to at least one of the shapes.\"@en ;\n\trdfs:range rdf:List ;    # members: sh:Shape ;\n\trdfs:isDefinedBy sh: .\n\n\nsh:PatternConstraintComponent\n\ta sh:ConstraintComponent ;\n\trdfs:label \"Pattern constraint component\"@en ;\n\trdfs:comment \"A constraint component that can be used to verify that every value node matches a given regular expression.\"@en ;\n\tsh:parameter sh:PatternConstraintComponent-pattern ;\n\tsh:parameter sh:PatternConstraintComponent-flags ;\n\trdfs:isDefinedBy sh: .\n\nsh:PatternConstraintComponent-pattern\n\ta sh:Parameter ;\n\tsh:path sh:pattern ;\n\tsh:datatype xsd:string ;\n\trdfs:isDefinedBy sh: .\n\nsh:PatternConstraintComponent-flags\n\ta sh:Parameter ;\n\tsh:path sh:flags ;\n\tsh:datatype xsd:string ;\n\tsh:optional true ;\n\trdfs:isDefinedBy sh: .\n\nsh:flags\n\ta rdf:Property ;\n\trdfs:label \"flags\"@en ;\n\trdfs:comment \"An optional flag to be used with regular expression pattern matching.\"@en ;\n\trdfs:range xsd:string ;\n\trdfs:isDefinedBy sh: .\n\nsh:pattern\n\ta rdf:Property ;\n\trdfs:label \"pattern\"@en ;\n\trdfs:comment \"Specifies a regular expression pattern that the string representations of the value nodes must match.\"@en ;\n\trdfs:range xsd:string ;\n\trdfs:isDefinedBy sh: .\n\n\nsh:PropertyConstraintComponent\n\ta sh:ConstraintComponent ;\n\trdfs:label \"Property constraint component\"@en ;\n\trdfs:comment \"A constraint component that can be used to verify that all value nodes conform to the given property shape.\"@en ;\n\tsh:parameter sh:PropertyConstraintComponent-property ;\n\trdfs:isDefinedBy sh: .\n\nsh:PropertyConstraintComponent-property\n\ta sh:Parameter ;\n\tsh:path sh:property ;\n\trdfs:isDefinedBy sh: .\n\nsh:property\n\ta rdf:Property ;\n\trdfs:label \"property\"@en ;\n\trdfs:comment \"Links a shape to its property shapes.\"@en ;\n\trdfs:domain sh:Shape ;\n\trdfs:range sh:PropertyShape ;\n\trdfs:isDefinedBy sh: .\n\n\nsh:QualifiedMaxCountConstraintComponent\n\ta sh:ConstraintComponent ;\n\trdfs:label \"Qualified-max-count constraint component\"@en ;\n\trdfs:comment \"A constraint component that can be used to verify that a specified maximum number of value nodes conforms to a given shape.\"@en ;\n\tsh:parameter sh:QualifiedMaxCountConstraintComponent-qualifiedMaxCount ;\n\tsh:parameter sh:QualifiedMaxCountConstraintComponent-qualifiedValueShape ;\n\tsh:parameter sh:QualifiedMaxCountConstraintComponent-qualifiedValueShapesDisjoint ;\n\trdfs:isDefinedBy sh: .\n\nsh:QualifiedMaxCountConstraintComponent-qualifiedMaxCount\n\ta sh:Parameter ;\n\tsh:path sh:qualifiedMaxCount ;\n\tsh:datatype xsd:integer ;\n\trdfs:isDefinedBy sh: .\n\nsh:QualifiedMaxCountConstraintComponent-qualifiedValueShape\n\ta sh:Parameter ;\n\tsh:path sh:qualifiedValueShape ;\n\trdfs:isDefinedBy sh: .\n\nsh:QualifiedMaxCountConstraintComponent-qualifiedValueShapesDisjoint\n\ta sh:Parameter ;\n\tsh:path sh:qualifiedValueShapesDisjoint ;\n\tsh:datatype xsd:boolean ;\n\tsh:optional true ;\n\trdfs:isDefinedBy sh: .\n\n\nsh:QualifiedMinCountConstraintComponent\n\ta sh:ConstraintComponent ;\n\trdfs:label \"Qualified-min-count constraint component\"@en ;\n\trdfs:comment \"A constraint component that can be used to verify that a specified minimum number of value nodes conforms to a given shape.\"@en ;\n\tsh:parameter sh:QualifiedMinCountConstraintComponent-qualifiedMinCount ;\n\tsh:parameter sh:QualifiedMinCountConstraintComponent-qualifiedValueShape ;\n\tsh:parameter sh:QualifiedMinCountConstraintComponent-qualifiedValueShapesDisjoint ;\n\trdfs:isDefinedBy sh: .\n\nsh:QualifiedMinCountConstraintComponent-qualifiedMinCount\n\ta sh:Parameter ;\n\tsh:path sh:qualifiedMinCount ;\n\tsh:datatype xsd:integer ;\n\trdfs:isDefinedBy sh: .\n\nsh:QualifiedMinCountConstraintComponent-qualifiedValueShape\n\ta sh:Parameter ;\n\tsh:path sh:qualifiedValueShape ;\n\trdfs:isDefinedBy sh: .\n\nsh:QualifiedMinCountConstraintComponent-qualifiedValueShapesDisjoint\n\ta sh:Parameter ;\n\tsh:path sh:qualifiedValueShapesDisjoint ;\n\tsh:datatype xsd:boolean ;\n\tsh:optional true ;\n\trdfs:isDefinedBy sh: .\n\nsh:qualifiedMaxCount\n\ta rdf:Property ;\n\trdfs:label \"qualified max count\"@en ;\n\trdfs:comment \"The maximum number of value nodes that can conform to the shape.\"@en ;\n\trdfs:range xsd:integer ;\n\trdfs:isDefinedBy sh: .\n\nsh:qualifiedMinCount\n\ta rdf:Property ;\n\trdfs:label \"qualified min count\"@en ;\n\trdfs:comment \"The minimum number of value nodes that must conform to the shape.\"@en ;\n\trdfs:range xsd:integer ;\n\trdfs:isDefinedBy sh: .\n\nsh:qualifiedValueShape\n\ta rdf:Property ;\n\trdfs:label \"qualified value shape\"@en ;\n\trdfs:comment \"The shape that a specified number of values must conform to.\"@en ;\n\trdfs:range sh:Shape ;\n\trdfs:isDefinedBy sh: .\n\t\nsh:qualifiedValueShapesDisjoint\n\ta rdf:Property ;\n\trdfs:label \"qualified value shapes disjoint\"@en ;\n\trdfs:comment \"Can be used to mark the qualified value shape to be disjoint with its sibling shapes.\"@en ;\n\trdfs:range xsd:boolean ;\n\trdfs:isDefinedBy sh: .\n\n\nsh:UniqueLangConstraintComponent\n\ta sh:ConstraintComponent ;\n\trdfs:label \"Unique-languages constraint component\"@en ;\n\trdfs:comment \"A constraint component that can be used to specify that no pair of value nodes may use the same language tag.\"@en ;\n\tsh:parameter sh:UniqueLangConstraintComponent-uniqueLang ;\n\trdfs:isDefinedBy sh: .\n\nsh:UniqueLangConstraintComponent-uniqueLang\n\ta sh:Parameter ;\n\tsh:path sh:uniqueLang ;\n\tsh:datatype xsd:boolean ;\n\tsh:maxCount 1 ;\n\trdfs:isDefinedBy sh: .\n\nsh:uniqueLang\n\ta rdf:Property ;\n\trdfs:label \"unique languages\"@en ;\n\trdfs:comment \"Specifies whether all node values must have a unique (or no) language tag.\"@en ;\n\trdfs:range xsd:boolean ;\n\trdfs:isDefinedBy sh: .\n\n\nsh:XoneConstraintComponent\n\ta sh:ConstraintComponent ;\n\trdfs:label \"Exactly one constraint component\"@en ;\n\trdfs:comment \"A constraint component that can be used to restrict the value nodes so that they conform to exactly one out of several provided shapes.\"@en ;\n\tsh:parameter sh:XoneConstraintComponent-xone ;\n\trdfs:isDefinedBy sh: .\n\nsh:XoneConstraintComponent-xone\n\ta sh:Parameter ;\n\tsh:path sh:xone ;\n\trdfs:isDefinedBy sh: .\n\nsh:xone\n\ta rdf:Property ;\n\trdfs:label \"exactly one\"@en ;\n\trdfs:comment \"Specifies a list of shapes so that the value nodes must conform to exactly one of the shapes.\"@en ;\n\trdfs:range rdf:List ;    # members: sh:Shape ;\n\trdfs:isDefinedBy sh: .\n\n\n# General SPARQL execution support --------------------------------------------\n\nsh:SPARQLExecutable\n\ta rdfs:Class ;\n\trdfs:label \"SPARQL executable\"@en ;\n\trdfs:comment \"The class of resources that encapsulate a SPARQL query.\"@en ;\n\trdfs:subClassOf rdfs:Resource ;\n\trdfs:isDefinedBy sh: .\n\nsh:SPARQLAskExecutable\n\ta rdfs:Class ;\n\trdfs:label \"SPARQL ASK executable\"@en ;\n\trdfs:comment \"The class of SPARQL executables that are based on an ASK query.\"@en ;\n\trdfs:subClassOf sh:SPARQLExecutable ;\n\trdfs:isDefinedBy sh: .\n\nsh:ask\n\ta rdf:Property ;\n\trdfs:label \"ask\"@en ;\n\trdfs:comment \"The SPARQL ASK query to execute.\"@en ;\n\trdfs:domain sh:SPARQLAskExecutable ;\n\trdfs:range xsd:string ;\n\trdfs:isDefinedBy sh: .\n\nsh:SPARQLConstructExecutable\n\ta rdfs:Class ;\n\trdfs:label \"SPARQL CONSTRUCT executable\"@en ;\n\trdfs:comment \"The class of SPARQL executables that are based on a CONSTRUCT query.\"@en ;\n\trdfs:subClassOf sh:SPARQLExecutable ;\n\trdfs:isDefinedBy sh: .\n\nsh:construct\n\ta rdf:Property ;\n\trdfs:label \"construct\"@en ;\n\trdfs:comment \"The SPARQL CONSTRUCT query to execute.\"@en ;\n\trdfs:domain sh:SPARQLConstructExecutable ;\n\trdfs:range xsd:string ;\n\trdfs:isDefinedBy sh: .\n\nsh:SPARQLSelectExecutable\n\ta rdfs:Class ;\n\trdfs:label \"SPARQL SELECT executable\"@en ;\n\trdfs:comment \"The class of SPARQL executables based on a SELECT query.\"@en ;\n\trdfs:subClassOf sh:SPARQLExecutable ;\n\trdfs:isDefinedBy sh: .\n\nsh:select\n\ta rdf:Property ;\n\trdfs:label \"select\"@en ;\n\trdfs:comment \"The SPARQL SELECT query to execute.\"@en ;\n\trdfs:range xsd:string ;\n\trdfs:domain sh:SPARQLSelectExecutable ;\n\trdfs:isDefinedBy sh: .\n\nsh:SPARQLUpdateExecutable\n\ta rdfs:Class ;\n\trdfs:label \"SPARQL UPDATE executable\"@en ;\n\trdfs:comment \"The class of SPARQL executables based on a SPARQL UPDATE.\"@en ;\n\trdfs:subClassOf sh:SPARQLExecutable ;\n\trdfs:isDefinedBy sh: .\n\nsh:update\n\ta rdf:Property ;\n\trdfs:label \"update\"@en ;\n\trdfs:comment \"The SPARQL UPDATE to execute.\"@en ;\n\trdfs:domain sh:SPARQLUpdateExecutable ;\n\trdfs:range xsd:string ;\n\trdfs:isDefinedBy sh: .\n\nsh:prefixes\n\ta rdf:Property ;\n\trdfs:label \"prefixes\"@en ;\n\trdfs:comment \"The prefixes that shall be applied before parsing the associated SPARQL query.\"@en ;\n\trdfs:domain sh:SPARQLExecutable ;\n\trdfs:range owl:Ontology ;\n\trdfs:isDefinedBy sh: .\n\nsh:PrefixDeclaration\n\ta rdfs:Class ;\n\trdfs:label \"Prefix declaration\"@en ;\n\trdfs:comment \"The class of prefix declarations, consisting of pairs of a prefix with a namespace.\"@en ;\n\trdfs:subClassOf rdfs:Resource ;\n\trdfs:isDefinedBy sh: .\n\nsh:declare\n\ta rdf:Property ;\n\trdfs:label \"declare\"@en ;\n\trdfs:comment \"Links a resource with its namespace prefix declarations.\"@en ;\n\trdfs:domain owl:Ontology ;\n\trdfs:range sh:PrefixDeclaration ;\n\trdfs:isDefinedBy sh: .\n\nsh:prefix\n\ta rdf:Property ;\n\trdfs:label \"prefix\"@en ;\n\trdfs:comment \"The prefix of a prefix declaration.\"@en ;\n\trdfs:domain sh:PrefixDeclaration ;\n\trdfs:range xsd:string ;\n\trdfs:isDefinedBy sh: .\n\nsh:namespace\n\ta rdf:Property ;\n\trdfs:label \"namespace\"@en ;\n\trdfs:comment \"The namespace associated with a prefix in a prefix declaration.\"@en ;\n\trdfs:domain sh:PrefixDeclaration ;\n\trdfs:range xsd:anyURI ;\n\trdfs:isDefinedBy sh: .\n\t\n\n# SPARQL-based Constraints support --------------------------------------------\n\nsh:SPARQLConstraintComponent\n\ta sh:ConstraintComponent ;\n\trdfs:label \"SPARQL constraint component\"@en ;\n\trdfs:comment \"A constraint component that can be used to define constraints based on SPARQL queries.\"@en ;\n\tsh:parameter sh:SPARQLConstraintComponent-sparql ;\n\trdfs:isDefinedBy sh: .\n\nsh:SPARQLConstraintComponent-sparql\n\ta sh:Parameter ;\n\tsh:path sh:sparql ;\n\trdfs:isDefinedBy sh: .\n\nsh:sparql\n\ta rdf:Property ;\n\trdfs:label \"constraint (in SPARQL)\"@en ;\n\trdfs:comment \"Links a shape with SPARQL constraints.\"@en ;\n\trdfs:domain sh:Shape ;\n\trdfs:range sh:SPARQLConstraint ;\n\trdfs:isDefinedBy sh: .\n\nsh:SPARQLConstraint\n\ta rdfs:Class ;\n\trdfs:label \"SPARQL constraint\"@en ;\n\trdfs:comment \"The class of constraints based on SPARQL SELECT queries.\"@en ;\n\trdfs:subClassOf sh:SPARQLSelectExecutable ;\n\trdfs:isDefinedBy sh: .\n\n\n# Non-validating constraint properties ----------------------------------------\n\nsh:defaultValue\n\ta rdf:Property ;\n\trdfs:label \"default value\"@en ;\n\trdfs:comment \"A default value for a property, for example for user interface tools to pre-populate input fields.\"@en ;\n\trdfs:domain sh:PropertyShape ;\n\trdfs:isDefinedBy sh: .\n\nsh:description\n\ta rdf:Property ;\n\trdfs:label \"description\"@en ;\n\trdfs:comment \"Human-readable descriptions for the property in the context of the surrounding shape.\"@en ;\n\trdfs:domain sh:PropertyShape ;\n\t# range: xsd:string or rdf:langString\n\trdfs:isDefinedBy sh: .\n\nsh:group\n\ta rdf:Property ;\n\trdfs:label \"group\"@en ;\n\trdfs:comment \"Can be used to link to a property group to indicate that a property shape belongs to a group of related property shapes.\"@en ;\n\trdfs:domain sh:PropertyShape ;\n\trdfs:range sh:PropertyGroup ;\n\trdfs:isDefinedBy sh: .\n\nsh:name\n\ta rdf:Property ;\n\trdfs:label \"name\"@en ;\n\trdfs:comment \"Human-readable labels for the property in the context of the surrounding shape.\"@en ;\n\trdfs:domain sh:PropertyShape ;\n\t# range: xsd:string or rdf:langString\n\trdfs:isDefinedBy sh: .\n\nsh:order\n\ta rdf:Property ;\n\trdfs:label \"order\"@en ;\n\trdfs:comment \"Specifies the relative order of this compared to its siblings. For example use 0 for the first, 1 for the second.\"@en ;\n\t# range: xsd:decimal or xsd:integer ;\n\trdfs:isDefinedBy sh: .\n\nsh:PropertyGroup\n\ta rdfs:Class ;\n\trdfs:label \"Property group\"@en ;\n\trdfs:comment \"Instances of this class represent groups of property shapes that belong together.\"@en ;\n\trdfs:subClassOf rdfs:Resource ;\n\trdfs:isDefinedBy sh: .\n\n\n# -----------------------------------------------------------------------------\n# SHACL ADVANCED FEATURES -----------------------------------------------------\n# -----------------------------------------------------------------------------\n\t\n\n# Advanced Target vocabulary --------------------------------------------------\n\nsh:target\n\ta rdf:Property ;\n\trdfs:label \"target\"@en ;\n\trdfs:comment \"Links a shape to a target specified by an extension language, for example instances of sh:SPARQLTarget.\"@en ;\n\trdfs:domain sh:Shape ;\n\trdfs:range sh:Target ;\n\trdfs:isDefinedBy sh: .\n\nsh:Target\n\ta rdfs:Class ;\n\trdfs:label \"Target\"@en ;\n\trdfs:comment \"The base class of targets such as those based on SPARQL queries.\"@en ;\n\trdfs:subClassOf rdfs:Resource ;\n\trdfs:isDefinedBy sh: .\n\nsh:TargetType\n\ta rdfs:Class ;\n\trdfs:label \"Target type\"@en ;\n\trdfs:comment \"The (meta) class for parameterizable targets.\tInstances of this are instantiated as values of the sh:target property.\"@en ;\n\trdfs:subClassOf rdfs:Class ;\n\trdfs:subClassOf sh:Parameterizable ;\n\trdfs:isDefinedBy sh: .\n\nsh:SPARQLTarget\n\ta rdfs:Class ;\n\trdfs:label \"SPARQL target\"@en ;\n\trdfs:comment \"The class of targets that are based on SPARQL queries.\"@en ;\n\trdfs:subClassOf sh:Target ;\n\trdfs:subClassOf sh:SPARQLAskExecutable ;\n\trdfs:subClassOf sh:SPARQLSelectExecutable ;\n\trdfs:isDefinedBy sh: .\n\nsh:SPARQLTargetType\n\ta rdfs:Class ;\n\trdfs:label \"SPARQL target type\"@en ;\n\trdfs:comment \"The (meta) class for parameterizable targets that are based on SPARQL queries.\"@en ;\n\trdfs:subClassOf sh:TargetType ;\n\trdfs:subClassOf sh:SPARQLAskExecutable ;\n\trdfs:subClassOf sh:SPARQLSelectExecutable ;\n\trdfs:isDefinedBy sh: .\n\n\n# Functions Vocabulary --------------------------------------------------------\n\nsh:Function\n\ta rdfs:Class ;\n\trdfs:label \"Function\"@en ;\n\trdfs:comment \"The class of SHACL functions.\"@en ;\n\trdfs:subClassOf sh:Parameterizable ;\n\trdfs:isDefinedBy sh: .\n\nsh:returnType\n\ta rdf:Property ;\n\trdfs:label \"return type\"@en ;\n\trdfs:comment \"The expected type of values returned by the associated function.\"@en ;\n\trdfs:domain sh:Function ;\n\trdfs:range rdfs:Class ;\n\trdfs:isDefinedBy sh: .\n\nsh:SPARQLFunction\n\ta rdfs:Class ;\n\trdfs:label \"SPARQL function\"@en ;\n\trdfs:comment \"A function backed by a SPARQL query - either ASK or SELECT.\"@en ;\n\trdfs:subClassOf sh:Function ;\n\trdfs:subClassOf sh:SPARQLAskExecutable ;\n\trdfs:subClassOf sh:SPARQLSelectExecutable ;\n\trdfs:isDefinedBy sh: .\n\n\n# Result Annotations ----------------------------------------------------------\n\nsh:resultAnnotation\n\ta rdf:Property ;\n\trdfs:label \"result annotation\"@en ;\n\trdfs:comment \"Links a SPARQL validator with zero or more sh:ResultAnnotation instances, defining how to derive additional result properties based on the variables of the SELECT query.\"@en ;\n\trdfs:domain sh:SPARQLSelectValidator ;\n\trdfs:range sh:ResultAnnotation ;\n\trdfs:isDefinedBy sh: .\n\nsh:ResultAnnotation\n\ta rdfs:Class ;\n\trdfs:label \"Result annotation\"@en ;\n\trdfs:comment \"A class of result annotations, which define the rules to derive the values of a given annotation property as extra values for a validation result.\"@en ;\n\trdfs:subClassOf rdfs:Resource ;\n\trdfs:isDefinedBy sh: .\n\nsh:annotationProperty\n\ta rdf:Property ;\n\trdfs:label \"annotation property\"@en ;\n\trdfs:comment \"The annotation property that shall be set.\"@en ;\n\trdfs:domain sh:ResultAnnotation ;\n\trdfs:range rdf:Property ;\n\trdfs:isDefinedBy sh: .\n\nsh:annotationValue\n\ta rdf:Property ;\n\trdfs:label \"annotation value\"@en ;\n\trdfs:comment \"The (default) values of the annotation property.\"@en ;\n\trdfs:domain sh:ResultAnnotation ;\n\trdfs:isDefinedBy sh: .\n\nsh:annotationVarName\n\ta rdf:Property ;\n\trdfs:label \"annotation variable name\"@en ;\n\trdfs:comment \"The name of the SPARQL variable from the SELECT clause that shall be used for the values.\"@en ;\n\trdfs:domain sh:ResultAnnotation ;\n\trdfs:range xsd:string ;\n\trdfs:isDefinedBy sh: .\n\n\t\n# Node Expressions ------------------------------------------------------------\n\nsh:this\n\ta rdfs:Resource ;\n\trdfs:label \"this\"@en ;\n\trdfs:comment \"A node expression that represents the current focus node.\"@en ;\n\trdfs:isDefinedBy sh: .\n\nsh:filterShape\n\ta rdf:Property ;\n\trdfs:label \"filter shape\"@en ;\n\trdfs:comment \"The shape that all input nodes of the expression need to conform to.\"@en ;\n\trdfs:range sh:Shape ;\n\trdfs:isDefinedBy sh: .\n\nsh:nodes\n\ta rdf:Property ;\n\trdfs:label \"nodes\"@en ;\n\trdfs:comment \"The node expression producing the input nodes of a filter shape expression.\"@en ;\n\trdfs:isDefinedBy sh: .\n\nsh:intersection\n\ta rdf:Property ;\n\trdfs:label \"intersection\"@en ;\n\trdfs:comment \"A list of node expressions that shall be intersected.\"@en ;\n\trdfs:isDefinedBy sh: .\n\nsh:union\n\ta rdf:Property ;\n\trdfs:label \"union\"@en ;\n\trdfs:comment \"A list of node expressions that shall be used together.\"@en ;\n\trdfs:isDefinedBy sh: .\n\n\n# Expression Constraints ------------------------------------------------------\n\nsh:ExpressionConstraintComponent\n\ta sh:ConstraintComponent ;\n\trdfs:label \"Expression constraint component\"@en ;\n\trdfs:comment \"A constraint component that can be used to verify that a given node expression produces true for all value nodes.\"@en ;\n\tsh:parameter sh:ExpressionConstraintComponent-expression ;\n\trdfs:isDefinedBy sh: .\n\nsh:ExpressionConstraintComponent-expression\n\ta sh:Parameter ;\n\tsh:path sh:expression ;\n\trdfs:isDefinedBy sh: .\n\nsh:expression\n\ta rdf:Property ;\n\trdfs:label \"expression\"@en ;\n\trdfs:comment \"The node expression that must return true for the value nodes.\"@en ;\n\trdfs:isDefinedBy sh: .\n\n\n# Rules -----------------------------------------------------------------------\n\nsh:Rule\n\ta rdfs:Class ;\n\trdfs:label \"Rule\"@en ;\n\trdfs:comment \"The class of SHACL rules. Never instantiated directly.\"@en ;\n\trdfs:subClassOf rdfs:Resource ;\n\trdfs:isDefinedBy sh: .\n\nsh:rule\n\ta rdf:Property ;\n\trdfs:label \"rule\"@en ;\n\trdfs:comment \"The rules linked to a shape.\"@en ;\n\trdfs:domain sh:Shape ;\n\trdfs:range sh:Rule ;\n\trdfs:isDefinedBy sh:  .\n\nsh:condition\n\ta rdf:Property ;\n\trdfs:label \"condition\"@en ;\n\trdfs:comment \"The shapes that the focus nodes need to conform to before a rule is executed on them.\"@en ;\n\trdfs:domain sh:Rule ;\n\trdfs:range sh:Shape ;\n\trdfs:isDefinedBy sh: .\n\nsh:TripleRule\n\ta rdfs:Class ;\n\trdfs:label \"A rule based on triple (subject, predicate, object) pattern.\"@en ;\n\trdfs:subClassOf sh:Rule ;\n\trdfs:isDefinedBy sh: .\n\nsh:subject\n\ta rdf:Property ;\n\trdfs:label \"subject\"@en ;\n\trdfs:comment \"An expression producing the resources that shall be inferred as subjects.\"@en ;\n\trdfs:domain sh:TripleRule ;\n\trdfs:isDefinedBy sh: .\n\nsh:predicate\n\ta rdf:Property ;\n\trdfs:label \"predicate\"@en ;\n\trdfs:comment \"An expression producing the properties that shall be inferred as predicates.\"@en ;\n\trdfs:domain sh:TripleRule ;\n\trdfs:isDefinedBy sh: .\n\nsh:object\n\ta rdf:Property ;\n\trdfs:label \"object\"@en ;\n\trdfs:comment \"An expression producing the nodes that shall be inferred as objects.\"@en ;\n\trdfs:domain sh:TripleRule ;\n\trdfs:isDefinedBy sh: .\n\nsh:SPARQLRule\n\ta rdfs:Class ;\n\trdfs:label \"SPARQL CONSTRUCT rule\"@en ;\n\trdfs:comment \"The class of SHACL rules based on SPARQL CONSTRUCT queries.\"@en ;\n\trdfs:subClassOf sh:Rule ;\n\trdfs:subClassOf sh:SPARQLConstructExecutable ;\n\trdfs:isDefinedBy sh: .\n\n\n# SHACL-JS --------------------------------------------------------------------\n\nsh:JSExecutable\n\ta rdfs:Class ;\n\trdfs:label \"JavaScript executable\"@en ;\n\trdfs:comment \"Abstract base class of resources that declare an executable JavaScript.\"@en ;\n\trdfs:subClassOf rdfs:Resource ;\n\trdfs:isDefinedBy sh: .\n\nsh:JSTarget\n\ta rdfs:Class ;\n\trdfs:label \"JavaScript target\"@en ;\n\trdfs:comment \"The class of targets that are based on JavaScript functions.\"@en ;\n\trdfs:subClassOf sh:Target ;\n\trdfs:subClassOf sh:JSExecutable ;\n\trdfs:isDefinedBy sh: .\n\nsh:JSTargetType\n\ta rdfs:Class ;\n\trdfs:label \"JavaScript target type\"@en ;\n\trdfs:comment \"The (meta) class for parameterizable targets that are based on JavaScript functions.\"@en ;\n\trdfs:subClassOf sh:TargetType ;\n\trdfs:subClassOf sh:JSExecutable ;\n\trdfs:isDefinedBy sh: .\n\nsh:JSConstraint\n\ta rdfs:Class ;\n\trdfs:label \"JavaScript-based constraint\"@en ;\n\trdfs:comment \"The class of constraints backed by a JavaScript function.\"@en ;\n\trdfs:subClassOf sh:JSExecutable ;\n\trdfs:isDefinedBy sh: .\n\t\nsh:JSConstraintComponent\n\ta sh:ConstraintComponent ;\n\trdfs:label \"JavaScript constraint component\"@en ;\n\trdfs:comment \"A constraint component with the parameter sh:js linking to a sh:JSConstraint containing a sh:script.\"@en ;\n  \tsh:parameter sh:JSConstraint-js ;\n\trdfs:isDefinedBy sh: .\n \nsh:JSConstraint-js\n\ta sh:Parameter ;\n\tsh:path sh:js ;\n\trdfs:isDefinedBy sh: .\n\t\nsh:js\n\ta rdf:Property ;\n\trdfs:label \"JavaScript constraint\"@en ;\n\trdfs:comment \"Constraints expressed in JavaScript.\" ;\n  \trdfs:range sh:JSConstraint ;\n\trdfs:isDefinedBy sh: .\n\nsh:jsFunctionName\n\ta rdf:Property ;\n\trdfs:label \"JavaScript function name\"@en ;\n\trdfs:comment \"The name of the JavaScript function to execute.\"@en ;\n\trdfs:domain sh:JSExecutable ;\n\trdfs:range xsd:string ;\n\trdfs:isDefinedBy sh: .\n\nsh:jsLibrary\n\ta rdf:Property ;\n\trdfs:label \"JavaScript library\"@en ;\n  \trdfs:comment \"Declares which JavaScript libraries are needed to execute this.\"@en ;\n\trdfs:range sh:JSLibrary ;\n\trdfs:isDefinedBy sh: .\n\nsh:jsLibraryURL\n\ta rdf:Property ;\n\trdfs:label \"JavaScript library URL\"@en ;\n\trdfs:comment \"Declares the URLs of a JavaScript library. This should be the absolute URL of a JavaScript file. Implementations may redirect those to local files.\"@en ;\n\trdfs:domain sh:JSLibrary ;\n\trdfs:range xsd:anyURI ;\n\trdfs:isDefinedBy sh: .\n\t\nsh:JSFunction\n\ta rdfs:Class ;\n  \trdfs:label \"JavaScript function\"@en ;\n\trdfs:comment \"The class of SHACL functions that execute a JavaScript function when called.\"@en ;\n\trdfs:subClassOf sh:Function ;\n\trdfs:subClassOf sh:JSExecutable ;\n\trdfs:isDefinedBy sh: .\n\nsh:JSLibrary\n\ta rdfs:Class ;\n\trdfs:label \"JavaScript library\"@en ;\n\trdfs:comment \"Represents a JavaScript library, typically identified by one or more URLs of files to include.\"@en ;\n\trdfs:subClassOf rdfs:Resource ;\n\trdfs:isDefinedBy sh: .\n\nsh:JSRule\n\ta rdfs:Class ;\n\trdfs:label \"JavaScript rule\"@en ;\n\trdfs:comment \"The class of SHACL rules expressed using JavaScript.\"@en ;\n\trdfs:subClassOf sh:JSExecutable ;\n\trdfs:subClassOf sh:Rule ;\n\trdfs:isDefinedBy sh: .\n\nsh:JSValidator\n\ta rdfs:Class ;\n  \trdfs:label \"JavaScript validator\"@en ;\n\trdfs:comment \"A SHACL validator based on JavaScript. This can be used to declare SHACL constraint components that perform JavaScript-based validation when used.\"@en ;\n  \trdfs:subClassOf sh:JSExecutable ;\n  \trdfs:subClassOf sh:Validator ;\n  \trdfs:isDefinedBy sh: .\n"}