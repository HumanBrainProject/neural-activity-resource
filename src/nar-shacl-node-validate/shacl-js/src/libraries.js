module.exports = {"http://datashapes.org/js/dash.js":"// Functions implementing the validators of SHACL-JS\n// Also include validators for the constraint components of the DASH namespace\n\n// Also included: implementations of the standard DASH functions\n\n// There is no validator for sh:property as this is expected to be\n// natively implemented by the surrounding engine.\n\nvar XSDIntegerTypes = new NodeSet();\nXSDIntegerTypes.add(T(\"xsd:integer\"));\n\nvar XSDDecimalTypes = new NodeSet();\nXSDDecimalTypes.addAll(XSDIntegerTypes.toArray());\nXSDDecimalTypes.add(T(\"xsd:decimal\"));\nXSDDecimalTypes.add(T(\"xsd:float\"));\n\nfunction validateAnd($value, $and) {\n\tvar shapes = new RDFQueryUtil($shapes).rdfListToArray($and);\n\tfor(var i = 0; i < shapes.length; i++) {\n\t\tif(!SHACL.nodeConformsToShape($value, shapes[i])) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\n\nfunction validateClass($value, $class) {\n\treturn new RDFQueryUtil($data).isInstanceOf($value, $class);\n}\n\nfunction validateClosed($value, $closed, $ignoredProperties, $currentShape) {\n\tif(!T(\"true\").equals($closed)) {\n\t\treturn;\n\t}\n\tvar allowed = $shapes.query().\n\t\tmatch($currentShape, \"sh:property\", \"?propertyShape\").\n\t\tmatch(\"?propertyShape\", \"sh:path\", \"?path\").\n\t\tfilter(function(solution) { return solution.path.isURI() } ).\n\t\tgetNodeSet(\"?path\");\n\tif($ignoredProperties) {\n\t\tallowed.addAll(new RDFQueryUtil($shapes).rdfListToArray($ignoredProperties));\n\t}\n\tvar results = [];\n\t$data.query().\n\t\tmatch($value, \"?predicate\", \"?object\").\n\t\tfilter(function(sol) { return !allowed.contains(sol.predicate)}).\n\t\tforEach(function(sol) { \n\t\t\tresults.push({ \n\t\t\t\tpath : sol.predicate,\n\t\t\t\tvalue : sol.object\n\t\t\t});\n\t\t});\n\treturn results;\n}\n\nfunction validateClosedByTypesNode($this, $closedByTypes) {\n\tif(!T(\"true\").equals($closedByTypes)) {\n\t\treturn;\n\t}\n\tvar results = [];\n\tvar allowedProperties = new NodeSet();\n\t$data.query().\n\t\tmatch($this, \"rdf:type\", \"?directType\").\n\t\tpath(\"?directType\", { zeroOrMore : T(\"rdfs:subClassOf\") }, \"?type\").\n\t\tforEachNode(\"?type\", function(type) {\n\t\t\t$shapes.query().\n\t\t\t\tmatch(type, \"sh:property\", \"?pshape\").\n\t\t\t\tmatch(\"?pshape\", \"sh:path\", \"?path\").\n\t\t\t\tfilter(function(sol) { return sol.path.isURI() }).\n\t\t\t\taddAllNodes(\"?path\", allowedProperties);\n\t\t});\n\t$data.query().\n\t\tmatch($this, \"?predicate\", \"?object\").\n\t\tfilter(function(sol) { return !T(\"rdf:type\").equals(sol.predicate) }).\n\t\tfilter(function(sol) { return !allowedProperties.contains(sol.predicate) }).\n\t\tforEach(function(sol) {\n\t\t\tresults.push({\n\t\t\t\tpath: sol.predicate,\n\t\t\t\tvalue: sol.object\n\t\t\t});\n\t\t})\n\treturn results;\n}\n\nfunction validateCoExistsWith($this, $path, $coExistsWith) {\n\tvar path = toRDFQueryPath($path);\n\tvar has1 = $data.query().path($this, path, null).getCount() > 0;\n\tvar has2 = $data.query().match($this, $coExistsWith, null).getCount() > 0;\n\treturn has1 == has2;\n}\n\nfunction validateDatatype($value, $datatype) {\n\tif($value.isLiteral()) {\n\t\treturn $datatype.equals($value.datatype) && isValidForDatatype($value.lex, $datatype);\n\t}\n\telse {\n\t\treturn false;\n\t}\n}\n\nfunction validateDisjoint($this, $value, $disjoint) {\n\treturn !$data.query().match($this, $disjoint, $value).hasSolution();\n}\n\nfunction validateEqualsProperty($this, $path, $equals) {\n\tvar results = [];\n\tvar path = toRDFQueryPath($path);\n\t$data.query().path($this, path, \"?value\").forEach(\n\t\tfunction(solution) {\n\t\t\tif(!$data.query().match($this, $equals, solution.value).hasSolution()) {\n\t\t\t\tresults.push({\n\t\t\t\t\tvalue: solution.value\n\t\t\t\t});\n\t\t\t}\n\t\t});\n\t$data.query().match($this, $equals, \"?value\").forEach(\n\t\tfunction(solution) {\n\t\t\tif(!$data.query().path($this, path, solution.value).hasSolution()) {\n\t\t\t\tresults.push({\n\t\t\t\t\tvalue: solution.value\n\t\t\t\t});\n\t\t\t}\n\t\t});\n\treturn results;\n}\n\nvar validateEqualsNode = function ($this, $equals) {\n    var results = [];\n    var solutions = 0;\n    $data.query().path($this, $equals, \"?value\").forEach(\n        function (solution) {\n            solutions++;\n            if (SHACL.compareNodes($this, solution['value']) !== 0) {\n                results.push({\n                    value: solution.value\n                });\n            }\n        });\n    if (results.length === 0 && solutions === 0) {\n        results.push({\n            value: $this\n        });\n    }\n    return results;\n};\n\nfunction validateHasValueNode($this, $hasValue) {\n\treturn $this.equals($hasValue);\n}\n\nfunction validateHasValueProperty($this, $path, $hasValue) {\n\tvar count = $data.query().path($this, toRDFQueryPath($path), $hasValue).getCount();\n\treturn count > 0;\n}\n\nfunction validateHasValueWithClass($this, $path, $hasValueWithClass) {\n\treturn $data.query().\n\t\t\tpath($this, toRDFQueryPath($path), \"?value\").\n\t\t\tfilter(function(sol) { return new RDFQueryUtil($data).isInstanceOf(sol.value, $hasValueWithClass) }).\n\t\t\thasSolution();\n}\n\nfunction validateIn($value, $in) {\n\tvar set = new NodeSet();\n\tset.addAll(new RDFQueryUtil($shapes).rdfListToArray($in));\n\treturn set.contains($value);\n}\n\nfunction validateLanguageIn($value, $languageIn) {\n\tif(!$value.isLiteral()) {\n\t\treturn false;\n\t}\n\tvar lang = $value.language;\n\tif(!lang || lang === \"\") {\n\t\treturn false;\n\t}\n\tvar ls = new RDFQueryUtil($shapes).rdfListToArray($languageIn);\n\tfor(var i = 0; i < ls.length; i++) {\n\t\tif(lang.startsWith(ls[i].lex)) {\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\nfunction validateLessThanProperty($this, $path, $lessThan) {\n\tvar results = [];\n\t$data.query().\n\t\tpath($this, toRDFQueryPath($path), \"?value\").\n\t\tmatch($this, $lessThan, \"?otherValue\").\n\t\tforEach(function(sol) {\n\t\t\t\t\tvar c = SHACL.compareNodes(sol.value, sol.otherValue);\n\t\t\t\t\tif(c == null || c >= 0) {\n\t\t\t\t\t\tresults.push({\n\t\t\t\t\t\t\tvalue: sol.value\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t});\n\treturn results;\n}\n\nfunction validateLessThanOrEqualsProperty($this, $path, $lessThanOrEquals) {\n\tvar results = [];\n\t$data.query().\n\t\tpath($this, toRDFQueryPath($path), \"?value\").\n\t\tmatch($this, $lessThanOrEquals, \"?otherValue\").\n\t\tforEach(function(sol) {\n\t\t\t\t\tvar c = SHACL.compareNodes(sol.value, sol.otherValue);\n\t\t\t\t\tif(c == null || c > 0) {\n\t\t\t\t\t\tresults.push({\n\t\t\t\t\t\t\tvalue: sol.value\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t});\n\treturn results;\n}\n\nfunction validateMaxCountProperty($this, $path, $maxCount) {\n\tvar count = $data.query().path($this, toRDFQueryPath($path), \"?any\").getCount();\n\treturn count <= Number($maxCount.value);\n}\n\nfunction validateMaxExclusive($value, $maxExclusive) {\n\treturn $value.isLiteral() && Number($value.lex) < Number($maxExclusive.lex);\n}\n\nfunction validateMaxInclusive($value, $maxInclusive) {\n\treturn $value.isLiteral() && Number($value.lex) <= Number($maxInclusive.lex);\n}\n\nfunction validateMaxLength($value, $maxLength) {\n\tif($value.isBlankNode()) {\n\t\treturn false;\n\t}\n\treturn $value.value.length <= Number($maxLength.lex);\n}\n\nfunction validateMinCountProperty($this, $path, $minCount) {\n\tvar count = $data.query().path($this, toRDFQueryPath($path), \"?any\").getCount();\n\treturn count >= Number($minCount.value);\n}\n\nfunction validateMinExclusive($value, $minExclusive) {\n\treturn $value.isLiteral() && Number($value.lex) > Number($minExclusive.lex);\n}\n\nfunction validateMinInclusive($value, $minInclusive) {\n\treturn $value.isLiteral() && Number($value.lex) >= Number($minInclusive.lex);\n}\n\nfunction validateMinLength($value, $minLength) {\n\tif($value.isBlankNode()) {\n\t\treturn false;\n\t}\n\treturn $value.value.length >= Number($minLength.lex);\n}\n\nfunction validateNodeKind($value, $nodeKind) {\n\tif($value.isBlankNode()) {\n\t\treturn T(\"sh:BlankNode\").equals($nodeKind) || \n\t\t\tT(\"sh:BlankNodeOrIRI\").equals($nodeKind) ||\n\t\t\tT(\"sh:BlankNodeOrLiteral\").equals($nodeKind);\n\t}\n\telse if($value.isURI()) {\n\t\treturn T(\"sh:IRI\").equals($nodeKind) || \n\t\t\tT(\"sh:BlankNodeOrIRI\").equals($nodeKind) ||\n\t\t\tT(\"sh:IRIOrLiteral\").equals($nodeKind);\n\t}\n\telse if($value.isLiteral()) {\n\t\treturn T(\"sh:Literal\").equals($nodeKind) || \n\t\t\tT(\"sh:BlankNodeOrLiteral\").equals($nodeKind) ||\n\t\t\tT(\"sh:IRIOrLiteral\").equals($nodeKind);\n\t}\n}\n\nfunction validateNode($value, $node) {\n\treturn SHACL.nodeConformsToShape($value, $node);\n}\n\nfunction validateNonRecursiveProperty($this, $path, $nonRecursive) {\n\tif(T(\"true\").equals($nonRecursive)) {\n\t\tif($data.query().path($this, toRDFQueryPath($path), $this).hasSolution()) {\n\t\t\treturn {\n\t\t\t\tpath: $path,\n\t\t\t\tvalue: $this\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunction validateNot($value, $not) {\n\treturn !SHACL.nodeConformsToShape($value, $not);\n}\n\nfunction validateOr($value, $or) {\n\tvar shapes = new RDFQueryUtil($shapes).rdfListToArray($or);\n\tfor(var i = 0; i < shapes.length; i++) {\n\t\tif(SHACL.nodeConformsToShape($value, shapes[i])) {\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\nfunction validatePattern($value, $pattern, $flags) {\n\tif($value.isBlankNode()) {\n\t\treturn false;\n\t}\n\tvar re = $flags ? new RegExp($pattern.lex, $flags.lex) : new RegExp($pattern.lex);\n\treturn re.test($value.value);\n}\n\nfunction validatePrimaryKeyProperty($this, $path, $uriStart) {\n\tif(!$this.isURI()) {\n\t\treturn \"Must be an IRI\";\n\t}\n\tif($data.query().path($this, toRDFQueryPath($path), null).getCount() != 1) {\n\t\treturn \"Must have exactly one value\";\n\t}\n\tvar value = $data.query().path($this, toRDFQueryPath($path), \"?value\").getNode(\"?value\");\n\tvar uri = $uriStart.lex + encodeURIComponent(value.value);\n\tif(!$this.uri.equals(uri)) {\n\t\treturn \"Does not have URI \" + uri;\n\t}\n}\n\nfunction validateQualifiedMaxCountProperty($this, $path, $qualifiedValueShape, $qualifiedValueShapesDisjoint, $qualifiedMaxCount, $currentShape) {\n\tvar c = validateQualifiedHelper($this, $path, $qualifiedValueShape, $qualifiedValueShapesDisjoint, $currentShape);\n\treturn c <= Number($qualifiedMaxCount.lex);\n}\n\nfunction validateQualifiedMinCountProperty($this, $path, $qualifiedValueShape, $qualifiedValueShapesDisjoint, $qualifiedMinCount, $currentShape) {\n\tvar c = validateQualifiedHelper($this, $path, $qualifiedValueShape, $qualifiedValueShapesDisjoint, $currentShape);\n\treturn c >= Number($qualifiedMinCount.lex);\n}\n\nfunction validateQualifiedHelper($this, $path, $qualifiedValueShape, $qualifiedValueShapesDisjoint, $currentShape) {\n\tvar siblingShapes = new NodeSet();\n\tif(T(\"true\").equals($qualifiedValueShapesDisjoint)) {\n\t\t$shapes.query().\n\t\t\tmatch(\"?parentShape\", \"sh:property\", $currentShape).\n\t\t\tmatch(\"?parentShape\", \"sh:property\", \"?sibling\").\n\t\t\tmatch(\"?sibling\", \"sh:qualifiedValueShape\", \"?siblingShape\").\n\t\t\tfilter(exprNotEquals(\"?siblingShape\", $qualifiedValueShape)) .\n\t\t\taddAllNodes(\"?siblingShape\", siblingShapes);\n\t}\n\treturn $data.query().\n\t\tpath($this, toRDFQueryPath($path), \"?value\").\n\t\tfilter(function(sol) { \n\t\t\treturn SHACL.nodeConformsToShape(sol.value, $qualifiedValueShape) &&\n\t\t\t\t!validateQualifiedConformsToASibling(sol.value, siblingShapes.toArray()); \n\t\t}).\n\t\tgetCount();\n}\n\nfunction validateQualifiedConformsToASibling(value, siblingShapes) {\n\tfor(var i = 0; i < siblingShapes.length; i++) {\n\t\tif(SHACL.nodeConformsToShape(value, siblingShapes[i])) {\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\nfunction validateRootClass($value, $rootClass) {\n\treturn $data.query().path($value, { zeroOrMore: T(\"rdfs:subClassOf\") }, $rootClass).hasSolution();\n}\n\nfunction validateStem($value, $stem) {\n\treturn $value.isURI() && $value.uri.startsWith($stem.lex);\n}\n\nfunction validateSubSetOf($this, $subSetOf, $value) {\n\treturn $data.query().match($this, $subSetOf, $value).hasSolution();\n}\n\nfunction validateUniqueLangProperty($this, $uniqueLang, $path) {\n\tif(!T(\"true\").equals($uniqueLang)) {\n\t\treturn;\n\t}\n\tvar map = {};\n\t$data.query().path($this, toRDFQueryPath($path), \"?value\").forEach(function(sol) {\n\t\tvar lang = sol.value.language;\n\t\tif(lang && lang != \"\") {\n\t\t\tvar old = map[lang];\n\t\t\tif(!old) {\n\t\t\t\tmap[lang] = 1;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tmap[lang] = old + 1;\n\t\t\t}\n\t\t}\n\t})\n\tvar results = [];\n\tfor(var lang in map) {\n\t\tif(map.hasOwnProperty(lang)) {\n\t\t\tvar count = map[lang];\n\t\t\tif(count > 1) {\n\t\t\t\tresults.push(\"Language \\\"\" + lang + \"\\\" has been used by \" + count + \" values\");\n\t\t\t}\n\t\t}\n\t}\n\treturn results;\n}\n\nfunction validateXone($value, $xone) {\n\tvar shapes = new RDFQueryUtil($shapes).rdfListToArray($xone);\n\tvar count = 0;\n\tfor(var i = 0; i < shapes.length; i++) {\n\t\tif(SHACL.nodeConformsToShape($value, shapes[i])) {\n\t\t\tcount++;\n\t\t}\n\t}\n\treturn count == 1;\n}\n\n\n// DASH functions -------------------------------------------------------------\n\n// dash:toString\nfunction dash_toString($arg) {\n\tif($arg.isLiteral()) {\n\t\treturn NodeFactory.literal($arg.lex, T(\"xsd:string\"));\n\t}\n\telse if($arg.isURI()) {\n\t\treturn NodeFactory.literal($arg.uri, T(\"xsd:string\"));\n\t}\n\telse {\n\t\treturn null;\n\t}\n}\n\n\n// DASH targets ---------------------------------------------------------------\n\n// dash:AllObjectsTarget\nfunction dash_allObjects() {\n\treturn $data.query().match(null, null, \"?object\").getNodeSet(\"?object\").toArray();\n}\n\n// dash:AllSubjectsTarget\nfunction dash_allSubjects() {\n\treturn $data.query().match(\"?subject\", null, null).getNodeSet(\"?subject\").toArray();\n}\n\n\n// Utilities ------------------------------------------------------------------\n\nfunction toRDFQueryPath(shPath) {\n    if (shPath.termType === \"Collection\") {\n        var paths = new RDFQueryUtil($shapes).rdfListToArray(shPath);\n        var result = [];\n        for (var i = 0; i < paths.length; i++) {\n            result.push(toRDFQueryPath(paths[i]));\n        }\n        return result;\n    }\n\tif(shPath.isURI()) {\n\t\treturn shPath;\n\t}\n\telse if(shPath.isBlankNode()) {\n\t\tvar util = new RDFQueryUtil($shapes);\n\t\tif($shapes.query().getObject(shPath, \"rdf:first\")) {\n\t\t\tvar paths = util.rdfListToArray(shPath);\n\t\t\tvar result = [];\n\t\t\tfor(var i = 0; i < paths.length; i++) {\n\t\t\t\tresult.push(toRDFQueryPath(paths[i]));\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\t\tvar alternativePath = $shapes.query().getObject(shPath, \"sh:alternativePath\");\n\t\tif(alternativePath) {\n\t\t\tvar paths = util.rdfListToArray(alternativePath);\n\t\t\tvar result = [];\n\t\t\tfor(var i = 0; i < paths.length; i++) {\n\t\t\t\tresult.push(toRDFQueryPath(paths[i]));\n\t\t\t}\n\t\t\treturn { or : result };\n\t\t}\n\t\tvar zeroOrMorePath = $shapes.query().getObject(shPath, \"sh:zeroOrMorePath\");\n\t\tif(zeroOrMorePath) {\n\t\t\treturn { zeroOrMore : toRDFQueryPath(zeroOrMorePath) };\n\t\t}\n\t\tvar oneOrMorePath = $shapes.query().getObject(shPath, \"sh:oneOrMorePath\");\n\t\tif(oneOrMorePath) {\n\t\t\treturn { oneOrMore : toRDFQueryPath(oneOrMorePath) };\n\t\t}\n\t\tvar zeroOrOnePath = $shapes.query().getObject(shPath, \"sh:zeroOrOnePath\");\n\t\tif(zeroOrOnePath) {\n\t\t\treturn { zeroOrOne : toRDFQueryPath(zeroOrOnePath) };\n\t\t}\n\t\tvar inversePath = $shapes.query().getObject(shPath, \"sh:inversePath\");\n\t\tif(inversePath) {\n\t\t\treturn { inverse : toRDFQueryPath(inversePath) };\n\t\t}\n\t}\n\tthrow \"Unsupported SHACL path \" + shPath;\n\t// TODO: implement conforming to AbstractQuery.path syntax\n\treturn shPath;\n}\n\n\n// Private helper functions\n\n//TODO: Support more datatypes\nfunction isValidForDatatype(lex, datatype) {\n\tif(XSDIntegerTypes.contains(datatype)) {\n\t\tvar r = parseInt(lex);\n\t\treturn !isNaN(r);\n\t}\n\telse if(XSDDecimalTypes.contains(datatype)) {\n\t\tvar r = parseFloat(lex);\n\t\treturn !isNaN(r);\n\t}\n\telse if (datatype.value === \"http://www.w3.org/2001/XMLSchema#boolean\") {\n        return lex === \"true\" || lex === \"false\";\n    }\n\telse {\n\t\treturn true;\n\t}\n}\n\nfunction RDFQueryUtil($source) {\n\tthis.source = $source;\n}\n\nRDFQueryUtil.prototype.getInstancesOf = function($class) {\n\tvar set = new NodeSet();\n\tvar classes = this.getSubClassesOf($class);\n\tclasses.add($class);\n\tvar car = classes.toArray();\n\tfor(var i = 0; i < car.length; i++) {\n\t\tset.addAll(RDFQuery(this.source).match(\"?instance\", \"rdf:type\", car[i]).getNodeArray(\"?instance\"));\n\t}\n\treturn set;\n}\n\nRDFQueryUtil.prototype.getObject = function($subject, $predicate) {\n\tif(!$subject) {\n\t\tthrow \"Missing subject\";\n\t}\n\tif(!$predicate) {\n\t\tthrow \"Missing predicate\";\n\t}\n\treturn RDFQuery(this.source).match($subject, $predicate, \"?object\").getNode(\"?object\");\n}\n\nRDFQueryUtil.prototype.getSubClassesOf = function($class) {\n\tvar set = new NodeSet();\n\tthis.walkSubjects(set, $class, T(\"rdfs:subClassOf\"));\n\treturn set;\n}\n\nRDFQueryUtil.prototype.isInstanceOf = function($instance, $class) {\n\tvar classes = this.getSubClassesOf($class);\n\tvar types = $data.query().match($instance, \"rdf:type\", \"?type\");\n\tfor(var n = types.nextSolution(); n; n = types.nextSolution()) {\n\t\tif(n.type.equals($class) || classes.contains(n.type)) {\n\t\t\ttypes.close();\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\nRDFQueryUtil.prototype.rdfListToArray = function($rdfList) {\n    if ($rdfList.elements != null) {\n        return $rdfList.elements;\n    } else {\n        var array = [];\n        while (!T(\"rdf:nil\").equals($rdfList)) {\n            array.push(this.getObject($rdfList, T(\"rdf:first\")));\n            $rdfList = this.getObject($rdfList, T(\"rdf:rest\"));\n        }\n        return array;\n    }\n}\n\nRDFQueryUtil.prototype.walkObjects = function($results, $subject, $predicate) {\n\tvar it = this.source.find($subject, $predicate, null);\n\tfor(var n = it.next(); n; n = it.next()) {\n\t\tif(!$results.contains(n.object)) {\n\t\t\t$results.add(n.object);\n\t\t\tthis.walkObjects($results, n.object, $predicate);\n\t\t}\n\t}\n}\n\nRDFQueryUtil.prototype.walkSubjects = function($results, $object, $predicate) {\n\tvar it = this.source.find(null, $predicate, $object);\n\tfor(var n = it.next(); n; n = it.next()) {\n\t\tif(!$results.contains(n.subject)) {\n\t\t\t$results.add(n.subject);\n\t\t\tthis.walkSubjects($results, n.subject, $predicate);\n\t\t}\n\t}\n}\n","http://datashapes.org/js/rdfquery.js":"// rdfquery.js\n// A simple RDF query library for JavaScript\n//\n// Contact: Holger Knublauch, TopQuadrant, Inc. (holger@topquadrant.com)\n//\n// The basic idea is that the function RDFQuery produces an initial\n// Query object, which starts with a single \"empty\" solution.\n// Each query object has a function nextSolution() producing an iteration\n// of variable bindings (\"volcano style\").\n// Each query object can be refined with subsequent calls to other\n// functions, producing new queries.\n// Invoking nextSolution on a query will pull solutions from its\n// predecessors in a chain of query objects.\n// The solution objects are plain JavaScript objects providing a\n// mapping from variable names to RDF Term objects.\n// Unless a query has been walked to exhaustion, .close() must be called.\n//\n// Finally, terminal functions such as .getNode() and .getArray() can be used\n// to produce individual values.  All terminal functions close the query.\n//\n// RDF Term/Node objects are expected to follow the contracts from the\n// RDF Representation Task Force's interface specification:\n// https://github.com/rdfjs/representation-task-force/blob/master/interface-spec.md\n//\n// In order to bootstrap all this, graph objects need to implement a\n// function .find(s, p, o) where each parameter is either an RDF term or null\n// producing an iterator object with a .next() function that produces RDF triples\n// (with attributes subject, predicate, object) or null when done.\n//\n// (Note I am not particularly a JavaScript guru so the modularization of this\n// script may be improved to hide private members from public API etc).\n\n/*\nExample:\n\n\tvar result = $data.query().\n\t\tmatch(\"owl:Class\", \"rdfs:label\", \"?label\").\n\t\tmatch(\"?otherClass\", \"rdfs:label\", \"?label\").\n\t\tfilter(function(sol) { return !T(\"owl:Class\").equals(sol.otherClass) }).\n\t\tgetNode(\"?otherClass\");\n\nEquivalent SPARQL:\n\t\tSELECT ?otherClass\n\t\tWHERE {\n\t\t\towl:Class rdfs:label ?label .\n\t\t\t?otherClass rdfs:label ?label .\n\t\t\tFILTER (owl:Class != ?otherClass) .\n\t\t} LIMIT 1\n*/\n\nif(!this[\"TermFactory\"]) {\n    // In some environments such as Nashorn this may already have a value\n    // In TopBraid this is redirecting to native Jena calls\n    TermFactory = {\n\n        REGEX_URI: /^([a-z][a-z0-9+.-]*):(?:\\/\\/((?:(?=((?:[a-z0-9-._~!$&'()*+,;=:]|%[0-9A-F]{2})*))(\\3)@)?(?=(\\[[0-9A-F:.]{2,}\\]|(?:[a-z0-9-._~!$&'()*+,;=]|%[0-9A-F]{2})*))\\5(?::(?=(\\d*))\\6)?)(\\/(?=((?:[a-z0-9-._~!$&'()*+,;=:@\\/]|%[0-9A-F]{2})*))\\8)?|(\\/?(?!\\/)(?=((?:[a-z0-9-._~!$&'()*+,;=:@\\/]|%[0-9A-F]{2})*))\\10)?)(?:\\?(?=((?:[a-z0-9-._~!$&'()*+,;=:@\\/?]|%[0-9A-F]{2})*))\\11)?(?:#(?=((?:[a-z0-9-._~!$&'()*+,;=:@\\/?]|%[0-9A-F]{2})*))\\12)?$/i,\n\n        impl : null,   // This needs to be connected to an API such as $rdf\n\n        // Globally registered prefixes for TTL short cuts\n        namespaces : {},\n\n        /**\n         * Registers a new namespace prefix for global TTL short cuts (qnames).\n         * @param prefix  the prefix to add\n         * @param namespace  the namespace to add for the prefix\n         */\n        registerNamespace : function(prefix, namespace) {\n            if(this.namespaces.prefix) {\n                throw \"Prefix \" + prefix + \" already registered\"\n            }\n            this.namespaces[prefix] = namespace;\n        },\n\n        /**\n         * Produces an RDF term from a TTL string representation.\n         * Also uses the registered prefixes.\n         * @param str  a string, e.g. \"owl:Thing\" or \"true\" or '\"Hello\"@en'.\n         * @return an RDF term\n         */\n        term : function(str) {\n            // TODO: this implementation currently only supports booleans and qnames - better overload to rdflib.js\n            if (\"true\" === str || \"false\" === str) {\n                return this.literal(str, (this.term(\"xsd:boolean\")));\n            }\n\n            if (str.match(/^\\d+$/)) {\n                return this.literal(str, (this.term(\"xsd:integer\")));\n            }\n\n            if (str.match(/^\\d+\\.\\d+$/)) {\n                return this.literal(str, (this.term(\"xsd:float\")));\n            }\n\n            var col = str.indexOf(\":\");\n            if (col > 0) {\n                var ns = this.namespaces[str.substring(0, col)];\n                if (ns != null) {\n                    return this.namedNode(ns + str.substring(col + 1));\n                } else {\n                    if (str.match(REGEX_URI)) {\n                        return this.namedNode(str)\n                    }\n                }\n            }\n            return this.literal(str);\n        },\n\n        /**\n         * Produces a new blank node.\n         * @param id  an optional ID for the node\n         */\n        blankNode : function(id) {\n            return this.impl.blankNode(id);\n        },\n\n        /**\n         * Produces a new literal.  For example .literal(\"42\", T(\"xsd:integer\")).\n         * @param lex  the lexical form, e.g. \"42\"\n         * @param langOrDatatype  either a language string or a URI node with the datatype\n         */\n        literal : function(lex, langOrDatatype) {\n            return this.impl.literal(lex, langOrDatatype)\n        },\n\n        // This function is basically left for Task Force compatibility, but the preferred function is uri()\n        namedNode : function(uri) {\n            return this.impl.namedNode(uri)\n        },\n\n        /**\n         * Produces a new URI node.\n         * @param uri  the URI of the node\n         */\n        uri : function(uri) {\n            return namedNode(uri);\n        }\n    }\n}\n\n// Install NodeFactory as an alias - unsure which name is best long term:\n// The official name in RDF is \"term\", while \"node\" is more commonly understood.\n// Oficially, a \"node\" must be in a graph though, while \"terms\" are independent.\nvar NodeFactory = TermFactory;\n\n\nNodeFactory.registerNamespace(\"dc\", \"http://purl.org/dc/elements/1.1/\")\nNodeFactory.registerNamespace(\"dcterms\", \"http://purl.org/dc/terms/\")\nNodeFactory.registerNamespace(\"rdf\", \"http://www.w3.org/1999/02/22-rdf-syntax-ns#\")\nNodeFactory.registerNamespace(\"rdfs\", \"http://www.w3.org/2000/01/rdf-schema#\")\nNodeFactory.registerNamespace(\"schema\", \"http://schema.org/\")\nNodeFactory.registerNamespace(\"sh\", \"http://www.w3.org/ns/shacl#\")\nNodeFactory.registerNamespace(\"skos\", \"http://www.w3.org/2004/02/skos/core#\")\nNodeFactory.registerNamespace(\"owl\", \"http://www.w3.org/2002/07/owl#\")\nNodeFactory.registerNamespace(\"xsd\", \"http://www.w3.org/2001/XMLSchema#\")\n\n// Candidates:\n// NodeFactory.registerNamespace(\"prov\", \"http://www.w3.org/ns/prov#\");\n\n/**\n * A shortcut for NodeFactory.term(str) - turns a TTL string representation of an RDF\n * term into a proper RDF term.\n * This will also use the globally registered namespace prefixes.\n * @param str  the string representation, e.g. \"owl:Thing\"\n * @returns\n */\nfunction T(str) {\n    return NodeFactory.term(str)\n}\n\n\n/**\n * Creates a query object for a given graph and optional initial solution.\n * The resulting object can be further refined using the functions on\n * AbstractQuery such as <code>match()</code> and <code>filter()</code>.\n * Functions such as <code>nextSolution()</code> can be used to get the actual results.\n * @param graph  the graph to query\n * @param initialSolution  the initial solutions or null for none\n * @returns a query object\n */\nfunction RDFQuery(graph, initialSolution) {\n    return new StartQuery(graph, initialSolution ? initialSolution : []);\n}\n\n\n// class AbstractQuery\n\nfunction AbstractQuery() {\n}\n\n// ----------------------------------------------------------------------------\n// Query constructor functions, can be chained together\n// ----------------------------------------------------------------------------\n\n/**\n * Creates a new query that adds a binding for a given variable into\n * each solution produced by the input query.\n * @param varName  the name of the variable to bind, starting with \"?\"\n * @param bindFunction  a function that takes a solution object\n *                      and returns a node or null based on it.\n */\nAbstractQuery.prototype.bind = function(varName, bindFunction) {\n    return new BindQuery(this, varName, bindFunction);\n}\n\n/**\n * Creates a new query that filters the solutions produced by this.\n * @param filterFunction  a function that takes a solution object\n *                        and returns true iff that solution is valid\n */\nAbstractQuery.prototype.filter = function(filterFunction) {\n    return new FilterQuery(this, filterFunction);\n}\n\n/**\n * Creates a new query that only allows the first n solutions through.\n * @param limit  the maximum number of results to allow\n */\nAbstractQuery.prototype.limit = function(limit) {\n    return new LimitQuery(this, limit);\n}\n\n/**\n * Creates a new query doing a triple match.\n * In each subject, predicate, object position, the values can either be\n * an RDF term object or null (wildcard) or a string.\n * If it is a string it may either be a variable (starting with \"?\")\n * or the TTL representation of an RDF term using the T() function.\n * @param s  the match subject\n * @param p  the match predicate\n * @param o  the match object\n */\nAbstractQuery.prototype.match = function(s, p, o) {\n    return new MatchQuery(this, s, p, o);\n}\n\n/**\n * Creates a new query that sorts all input solutions by the bindings\n * for a given variable.\n * @param varName  the name of the variable to sort by, starting with \"?\"\n */\nAbstractQuery.prototype.orderBy = function(varName) {\n    return new OrderByQuery(this, varName);\n}\n\n/**\n * Creates a new query doing a match where the predicate may be a RDF Path object.\n * Note: This is currently not using lazy evaluation and will always walk all matches.\n * Path syntax:\n * - PredicatePaths: NamedNode\n * - SequencePaths: [path1, path2]\n * - AlternativePaths: { or : [ path1, path2 ] }\n * - InversePaths: { inverse : path }   LIMITATION: Only supports NamedNodes for path here\n * - ZeroOrMorePaths: { zeroOrMore : path }\n * - OneOrMorePaths: { oneOrMore : path }\n * - ZeroOrOnePaths: { zeroOrOne : path }\n * @param s  the match subject or a variable name (string) - must have a value\n *           at execution time!\n * @param path  the match path object (e.g. a NamedNode for a simple predicate hop)\n * @param o  the match object or a variable name (string)\n */\nAbstractQuery.prototype.path = function(s, path, o) {\n    if(path && path.value && path.isURI()) {\n        return new MatchQuery(this, s, path, o);\n    }\n    else {\n        return new PathQuery(this, s, path, o);\n    }\n}\n\n// TODO: add other SPARQL-like query types\n//       - .distinct()\n//       - .union(otherQuery)\n\n\n// ----------------------------------------------------------------------------\n// Terminal functions - convenience functions to get values.\n// All these functions close the solution iterators.\n// ----------------------------------------------------------------------------\n\n/**\n * Adds all nodes produced by a given solution variable into a set.\n * The set must have an add(node) function.\n * @param varName  the name of the variable, starting with \"?\"\n * @param set  the set to add to\n */\nAbstractQuery.prototype.addAllNodes = function(varName, set) {\n    var attrName = var2Attr(varName);\n    for(var sol = this.nextSolution(); sol; sol = this.nextSolution()) {\n        var node = sol[attrName];\n        if(node) {\n            set.add(node);\n        }\n    }\n}\n\n/**\n * Produces an array of triple objects where each triple object has properties\n * subject, predicate and object derived from the provided template values.\n * Each of these templates can be either a variable name (starting with '?'),\n * an RDF term string (such as \"rdfs:label\") or a JavaScript node object.\n * @param subject  the subject node\n * @param predicate  the predicate node\n * @param object  the object node\n */\nAbstractQuery.prototype.construct = function(subject, predicate, object) {\n    var results = [];\n    for(var sol = this.nextSolution(); sol; sol = this.nextSolution()) {\n        var s = null;\n        if(typeof subject === 'string') {\n            if(subject.indexOf('?') == 0) {\n                s = sol[var2Attr(subject)];\n            }\n            else {\n                s = T(subject);\n            }\n        }\n        else {\n            s = subject;\n        }\n        var p = null;\n        if(typeof predicate === 'string') {\n            if(predicate.indexOf('?') == 0) {\n                p = sol[var2Attr(predicate)];\n            }\n            else {\n                p = T(predicate);\n            }\n        }\n        else {\n            p = predicate;\n        }\n\n        var o = null;\n        if(typeof object === 'string') {\n            if(object.indexOf('?') == 0) {\n                o = sol[var2Attr(object)];\n            }\n            else {\n                o = T(object);\n            }\n        }\n        else {\n            o = object;\n        }\n\n        if(s && p && o) {\n            results.push({ subject: s, predicate: p, object: o});\n        }\n    }\n    return results;\n}\n\n/**\n * Executes a given function for each solution.\n * @param callback  a function that takes a solution as argument\n */\nAbstractQuery.prototype.forEach = function(callback) {\n    for(var n = this.nextSolution(); n; n = this.nextSolution()) {\n        callback(n);\n    }\n}\n\n/**\n * Executes a given function for each node in a solution set.\n * @param varName  the name of a variable, starting with \"?\"\n * @param callback  a function that takes a node as argument\n */\nAbstractQuery.prototype.forEachNode = function(varName, callback) {\n    var attrName = var2Attr(varName);\n    for(var sol = this.nextSolution(); sol; sol = this.nextSolution()) {\n        var node = sol[attrName];\n        if(node) {\n            callback(node);\n        }\n    }\n}\n\n/**\n * Turns all result solutions into an array.\n * @return an array consisting of solution objects\n */\nAbstractQuery.prototype.getArray = function() {\n    var results = [];\n    for(var n = this.nextSolution(); n != null; n = this.nextSolution()) {\n        results.push(n);\n    }\n    return results;\n}\n\n/**\n * Gets the number of (remaining) solutions.\n * @return the count\n */\nAbstractQuery.prototype.getCount = function() {\n    return this.getArray().length; // Quick and dirty implementation\n}\n\n/**\n * Gets the next solution and, if that exists, returns the binding for a\n * given variable from that solution.\n * @param varName  the name of the binding to get, starting with \"?\"\n * @return the value of the variable or null or undefined if it doesn't exist\n */\nAbstractQuery.prototype.getNode = function(varName) {\n    var s = this.nextSolution();\n    if(s) {\n        this.close();\n        return s[var2Attr(varName)];\n    }\n    else {\n        return null;\n    }\n}\n\n/**\n * Turns all results into an array of bindings for a given variable.\n * @return an array consisting of RDF node objects\n */\nAbstractQuery.prototype.getNodeArray = function(varName) {\n    var results = [];\n    var attr = var2Attr(varName);\n    for(var n = this.nextSolution(); n != null; n = this.nextSolution()) {\n        results.push(n[attr]);\n    }\n    return results;\n}\n\n/**\n * Turns all result bindings for a given variable into a set.\n * The set has functions .contains and .toArray.\n * @param varName  the name of the variable, starting with \"?\"\n * @return a set consisting of RDF node objects\n */\nAbstractQuery.prototype.getNodeSet = function(varName) {\n    var results = new NodeSet();\n    var attr = var2Attr(varName);\n    for(var n = this.nextSolution(); n != null; n = this.nextSolution()) {\n        results.add(n[attr]);\n    }\n    return results;\n}\n\n/**\n * Queries the underlying graph for the object of a subject/predicate combination,\n * where either subject or predicate can be a variable which is substituted with\n * a value from the next input solution.\n * Note that even if there are multiple solutions it will just return the \"first\"\n * one and since the order of triples in RDF is undefined this may lead to random results.\n * Unbound values produce errors.\n * @param subject  an RDF term or a variable (starting with \"?\") or a TTL representation\n * @param predicate  an RDF term or a variable (starting with \"?\") or a TTL representation\n * @return the object of the \"first\" triple matching the subject/predicate combination\n */\nAbstractQuery.prototype.getObject = function(subject, predicate) {\n    var sol = this.nextSolution();\n    if(sol) {\n        this.close();\n        var s;\n        if(typeof subject === 'string') {\n            if(subject.indexOf('?') == 0) {\n                s = sol[var2Attr(subject)];\n            }\n            else {\n                s = T(subject);\n            }\n        }\n        else {\n            s = subject;\n        }\n        if(!s) {\n            throw \"getObject() called with null subject\";\n        }\n        var p;\n        if(typeof predicate === 'string') {\n            if(predicate.indexOf('?') == 0) {\n                p = sol[var2Attr(predicate)];\n            }\n            else {\n                p = T(predicate);\n            }\n        }\n        else {\n            p = predicate;\n        }\n        if(!p) {\n            throw \"getObject() called with null predicate\";\n        }\n\n        var it = this.source.find(s, p, null);\n        var triple = it.next();\n        if(triple) {\n            it.close();\n            return triple.object;\n        }\n    }\n    return null;\n}\n\n/**\n * Tests if there is any solution and closes the query.\n * @return true if there is another solution\n */\nAbstractQuery.prototype.hasSolution = function() {\n    if(this.nextSolution()) {\n        this.close();\n        return true;\n    }\n    else {\n        return false;\n    }\n}\n\n\n// ----------------------------------------------------------------------------\n// Expression functions - may be used in filter and bind queries\n// ----------------------------------------------------------------------------\n\n/**\n * Creates a function that takes a solution and compares a given node with\n * the binding of a given variable from that solution.\n * @param varName  the name of the variable (starting with \"?\")\n * @param node  the node to compare with\n * @returns true if the solution's variable equals the node\n */\nfunction exprEquals(varName, node) {\n    return function(sol) {\n        return node.equals(sol[var2Attr(varName)]);\n    }\n}\n\n/**\n * Creates a function that takes a solution and compares a given node with\n * the binding of a given variable from that solution.\n * @param varName  the name of the variable (starting with \"?\")\n * @param node  the node to compare with\n * @returns true if the solution's variable does not equal the node\n */\nfunction exprNotEquals(varName, node) {\n    return function(sol) {\n        return !node.equals(sol[var2Attr(varName)]);\n    }\n}\n\n\n// ----------------------------------------------------------------------------\n// END OF PUBLIC API ----------------------------------------------------------\n// ----------------------------------------------------------------------------\n\n\n// class BindQuery\n// Takes all input solutions but adds a value for a given variable so that\n// the value is computed by a given function based on the current solution.\n// It is illegal to use a variable that already has a value from the input.\n\nfunction BindQuery(input, varName, bindFunction) {\n    this.attr = var2Attr(varName);\n    this.source = input.source;\n    this.input = input;\n    this.bindFunction = bindFunction;\n}\n\nBindQuery.prototype = Object.create(AbstractQuery.prototype);\n\nBindQuery.prototype.close = function() {\n    this.input.close();\n}\n\n// Pulls the next result from the input Query and passes it into\n// the given bind function to add a new node\nBindQuery.prototype.nextSolution = function() {\n    var result = this.input.nextSolution();\n    if(result == null) {\n        return null;\n    }\n    else {\n        var newNode = this.bindFunction(result);\n        if(newNode) {\n            result[this.attr] = newNode;\n        }\n        return result;\n    }\n}\n\n\n// class FilterQuery\n// Filters the incoming solutions, only letting through those where\n// filterFunction(solution) returns true\n\nfunction FilterQuery(input, filterFunction) {\n    this.source = input.source;\n    this.input = input;\n    this.filterFunction = filterFunction;\n}\n\nFilterQuery.prototype = Object.create(AbstractQuery.prototype);\n\nFilterQuery.prototype.close = function() {\n    this.input.close();\n}\n\n// Pulls the next result from the input Query and passes it into\n// the given filter function\nFilterQuery.prototype.nextSolution = function() {\n    for(;;) {\n        var result = this.input.nextSolution();\n        if(result == null) {\n            return null;\n        }\n        else if(this.filterFunction(result) === true) {\n            return result;\n        }\n    }\n}\n\n\n// class LimitQuery\n// Only allows the first n values of the input query through\n\nfunction LimitQuery(input, limit) {\n    this.source = input.source;\n    this.input = input;\n    this.limit = limit;\n}\n\nLimitQuery.prototype = Object.create(AbstractQuery.prototype);\n\nLimitQuery.prototype.close = function() {\n    this.input.close();\n}\n\n// Pulls the next result from the input Query unless the number\n// of previous calls has exceeded the given limit\nLimitQuery.prototype.nextSolution = function() {\n    if(this.limit > 0) {\n        this.limit--;\n        return this.input.nextSolution();\n    }\n    else {\n        this.input.close();\n        return null;\n    }\n}\n\n\n// class MatchQuery\n// Joins the solutions from the input Query with triple matches against\n// the current input graph.\n\nfunction MatchQuery(input, s, p, o) {\n    this.source = input.source;\n    this.input = input;\n    if(typeof s === 'string') {\n        if(s.indexOf('?') == 0) {\n            this.sv = var2Attr(s);\n        }\n        else {\n            this.s = T(s);\n        }\n    }\n    else {\n        this.s = s;\n    }\n    if(typeof p === 'string') {\n        if(p.indexOf('?') == 0) {\n            this.pv = var2Attr(p);\n        }\n        else {\n            this.p = T(p);\n        }\n    }\n    else {\n        this.p = p;\n    }\n    if(typeof o === 'string') {\n        if(o.indexOf('?') == 0) {\n            this.ov = var2Attr(o);\n        }\n        else {\n            this.o = T(o);\n        }\n    }\n    else {\n        this.o = o;\n    }\n}\n\nMatchQuery.prototype = Object.create(AbstractQuery.prototype);\n\nMatchQuery.prototype.close = function() {\n    this.input.close();\n    if(this.ownIterator) {\n        this.ownIterator.close();\n    }\n}\n\n// This pulls the first solution from the input Query and uses it to\n// create an \"ownIterator\" which applies the input solution to those\n// specified by s, p, o.\n// Once this \"ownIterator\" has been exhausted, it moves to the next\n// solution from the input Query, and so on.\n// At each step, it produces the union of the input solutions plus the\n// own solutions.\nMatchQuery.prototype.nextSolution = function() {\n\n    var oit = this.ownIterator;\n    if(oit) {\n        var n = oit.next();\n        if(n != null) {\n            var result = createSolution(this.inputSolution);\n            if(this.sv) {\n                result[this.sv] = n.subject;\n            }\n            if(this.pv) {\n                result[this.pv] = n.predicate;\n            }\n            if(this.ov) {\n                result[this.ov] = n.object;\n            }\n            return result;\n        }\n        else {\n            delete this.ownIterator; // Mark as exhausted\n        }\n    }\n\n    // Pull from input\n    this.inputSolution = this.input.nextSolution();\n    if(this.inputSolution) {\n        var sm = this.sv ? this.inputSolution[this.sv] : this.s;\n        var pm = this.pv ? this.inputSolution[this.pv] : this.p;\n        var om = this.ov ? this.inputSolution[this.ov] : this.o;\n        this.ownIterator = this.source.find(sm, pm, om);\n        return this.nextSolution();\n    }\n    else {\n        return null;\n    }\n}\n\n\n// class OrderByQuery\n// Sorts all solutions from the input stream by a given variable\n\nfunction OrderByQuery(input, varName) {\n    this.input = input;\n    this.source = input.source;\n    this.attrName = var2Attr(varName);\n}\n\nOrderByQuery.prototype = Object.create(AbstractQuery.prototype);\n\nOrderByQuery.prototype.close = function() {\n    this.input.close();\n}\n\nOrderByQuery.prototype.nextSolution = function() {\n    if(!this.solutions) {\n        this.solutions = this.input.getArray();\n        var attrName = this.attrName;\n        this.solutions.sort(function(s1, s2) {\n            return compareTerms(s1[attrName], s2[attrName]);\n        });\n        this.index = 0;\n    }\n    if(this.index < this.solutions.length) {\n        return this.solutions[this.index++];\n    }\n    else {\n        return null;\n    }\n}\n\n\n// class PathQuery\n// Expects subject and path to be bound and produces all bindings\n// for the object variable or matches that by evaluating the given path\n\nfunction PathQuery(input, subject, path, object) {\n    this.input = input;\n    this.source = input.source;\n    if(typeof subject === 'string' && subject.indexOf(\"?\") == 0) {\n        this.subjectAttr = var2Attr(subject);\n    }\n    else {\n        this.subject = subject;\n    }\n    if(path == null) {\n        throw \"Path cannot be unbound\";\n    }\n    if(typeof path === 'string') {\n        this.path_ = T(path);\n    }\n    else {\n        this.path_ = path;\n    }\n    if(typeof object === 'string' && object.indexOf(\"?\") == 0) {\n        this.objectAttr = var2Attr(object);\n    }\n    else {\n        this.object = object;\n    }\n}\n\nPathQuery.prototype = Object.create(AbstractQuery.prototype);\n\nPathQuery.prototype.close = function() {\n    this.input.close();\n}\n\nPathQuery.prototype.nextSolution = function() {\n\n    var r = this.pathResults;\n    if(r) {\n        var n = r[this.pathIndex++];\n        var result = createSolution(this.inputSolution);\n        if(this.objectAttr) {\n            result[this.objectAttr] = n;\n        }\n        if(this.pathIndex == r.length) {\n            delete this.pathResults; // Mark as exhausted\n        }\n        return result;\n    }\n\n    // Pull from input\n    this.inputSolution = this.input.nextSolution();\n    if(this.inputSolution) {\n        var sm = this.subjectAttr ? this.inputSolution[this.subjectAttr] : this.subject;\n        if(sm == null) {\n            throw \"Path cannot have unbound subject\";\n        }\n        var om = this.objectAttr ? this.inputSolution[this.objectAttr] : this.object;\n        var pathResultsSet = new NodeSet();\n        addPathValues(this.source, sm, this.path_, pathResultsSet);\n        this.pathResults = pathResultsSet.toArray();\n        if(this.pathResults.length == 0) {\n            delete this.pathResults;\n        }\n        else if(om) {\n            delete this.pathResults;\n            if(pathResultsSet.contains(om)) {\n                return this.inputSolution;\n            }\n        }\n        else {\n            this.pathIndex = 0;\n        }\n        return this.nextSolution();\n    }\n    else {\n        return null;\n    }\n}\n\n\n// class StartQuery\n// This simply produces a single result: the initial solution\n\nfunction StartQuery(source, initialSolution) {\n    this.source = source;\n    if (initialSolution && initialSolution.length > 0) {\n        this.solution = initialSolution;\n    } else {\n        this.solution = [{}];\n    }\n}\n\nStartQuery.prototype = Object.create(AbstractQuery.prototype);\n\nStartQuery.prototype.close = function() {\n}\n\nStartQuery.prototype.nextSolution = function() {\n    if (this.solution) {\n        if (this.solution.length > 0) {\n            return this.solution.shift();\n        } else {\n            delete this.solution;\n        }\n    }\n}\n\n\n// Helper functions\n\nfunction createSolution(base) {\n    var result = {};\n    for(var attr in base) {\n        if(base.hasOwnProperty(attr)) {\n            result[attr] = base[attr];\n        }\n    }\n    return result;\n}\n\n\nfunction compareTerms(t1, t2) {\n    if(!t1) {\n        return !t2 ? 0 : 1;\n    }\n    else if(!t2) {\n        return -1;\n    }\n    var bt = t1.termType.localeCompare(t2.termType);\n    if(bt != 0) {\n        return bt;\n    }\n    else {\n        // TODO: Does not handle numeric or date comparison\n        var bv = t1.value.localeCompare(t2.value);\n        if(bv != 0) {\n            return bv;\n        }\n        else {\n            if(t1.isLiteral()) {\n                var bd = t1.datatype.uri.localeCompare(t2.datatype.uri);\n                if(bd != 0) {\n                    return bd;\n                }\n                else if(T(\"rdf:langString\").equals(t1.datatype)) {\n                    return t1.language.localeCompare(t2.language);\n                }\n                else {\n                    return 0;\n                }\n            }\n            else {\n                return 0;\n            }\n        }\n    }\n}\n\nfunction getLocalName(uri) {\n    // TODO: This is not the 100% correct local name algorithm\n    var index = uri.lastIndexOf(\"#\");\n    if(index < 0) {\n        index = uri.lastIndexOf(\"/\");\n    }\n    if(index < 0) {\n        throw \"Cannot get local name of \" + uri;\n    }\n    return uri.substring(index + 1);\n}\n\n\n// class NodeSet\n// (a super-primitive implementation for now!)\n\nfunction NodeSet() {\n    this.values = [];\n}\n\nNodeSet.prototype.add = function(node) {\n    if(!this.contains(node)) {\n        this.values.push(node);\n    }\n}\n\nNodeSet.prototype.addAll = function(nodes) {\n    for(var i = 0; i < nodes.length; i++) {\n        this.add(nodes[i]);\n    }\n}\n\nNodeSet.prototype.contains = function(node) {\n    for(var i = 0; i < this.values.length; i++) {\n        if(this.values[i].equals(node)) {\n            return true;\n        }\n    }\n    return false;\n}\n\nNodeSet.prototype.forEach = function(callback) {\n    for(var i = 0; i < this.values.length; i++) {\n        callback(this.values[i]);\n    }\n}\n\nNodeSet.prototype.size = function() {\n    return this.values.length;\n}\n\nNodeSet.prototype.toArray = function() {\n    return this.values;\n}\n\nNodeSet.prototype.toString = function() {\n    var str = \"NodeSet(\" + this.size() + \"): [\";\n    var arr = this.toArray();\n    for(var i = 0; i < arr.length; i++) {\n        if(i > 0) {\n            str += \", \";\n        }\n        str += arr[i];\n    }\n    return str + \"]\";\n}\n\n\nfunction var2Attr(varName) {\n    if(!varName.indexOf(\"?\") == 0) {\n        throw \"Variable name must start with ?\";\n    }\n    if(varName.length == 1) {\n        throw \"Variable name too short\";\n    }\n    return varName.substring(1);\n}\n\n\n\n// Simple Path syntax implementation:\n// Adds all matches for a given subject and path combination into a given NodeSet.\n// This should really be doing lazy evaluation and only up to the point\n// where the match object is found.\nfunction addPathValues(graph, subject, path, set) {\n    if(path.uri) {\n        set.addAll(RDFQuery(graph).match(subject, path, \"?object\").getNodeArray(\"?object\"));\n    }\n    else if(Array.isArray(path)) {\n        var s = new NodeSet();\n        s.add(subject);\n        for(var i = 0; i < path.length; i++) {\n            var a = s.toArray();\n            s = new NodeSet();\n            for(var j = 0; j < a.length; j++) {\n                addPathValues(graph, a[j], path[i], s);\n            }\n        }\n        set.addAll(s.toArray());\n    }\n    else if(path.or) {\n        for(var i = 0; i < path.or.length; i++) {\n            addPathValues(graph, subject, path.or[i], set);\n        }\n    }\n    else if(path.inverse) {\n        if(path.inverse.isURI()) {\n            set.addAll(RDFQuery(graph).match(\"?subject\", path.inverse, subject).getNodeArray(\"?subject\"));\n        }\n        else {\n            throw \"Unsupported: Inverse paths only work for named nodes\";\n        }\n    }\n    else if(path.zeroOrOne) {\n        addPathValues(graph, subject, path.zeroOrOne, set);\n        set.add(subject);\n    }\n    else if(path.zeroOrMore) {\n        walkPath(graph, subject, path.zeroOrMore, set, new NodeSet());\n        set.add(subject);\n    }\n    else if(path.oneOrMore) {\n        walkPath(graph, subject, path.oneOrMore, set, new NodeSet());\n    }\n    else {\n        throw \"Unsupported path object: \" + path;\n    }\n}\n\nfunction walkPath(graph, subject, path, set, visited) {\n    visited.add(subject);\n    var s = new NodeSet();\n    addPathValues(graph, subject, path, s);\n    var a = s.toArray();\n    set.addAll(a);\n    for(var i = 0; i < a.length; i++) {\n        if(!visited.contains(a[i])) {\n            walkPath(graph, a[i], path, set, visited);\n        }\n    }\n}"}